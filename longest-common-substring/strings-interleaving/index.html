<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/libs/katex/katex.min.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/libs/highlight/github.min.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/franklin.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/poole_hyde.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <title>Strings Interleaving</title> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunr.min.js"></script> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunr_index.js"></script> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunrclient.min.js"></script> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <br> <img src="/Dynamic-Programming-Patterns/assets/infra/DP.svg" style="width: 160px; height: auto; display: inline"> <h1> <div style="line-height:18px; font-size: 20px; opacity: 0.85"><a href="/Dynamic-Programming-Patterns/">Dynamic Programming Patterns</a></div> </h1> <div style="line-height:18px; font-size: 15px; opacity: 0.85">by <a href="https://github.com/rfhklwt">Inia Owlet</a></div> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9"> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/"><b>Overview</b></a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/introduction"><b>Introduction</b></a> <br> <div class=course-section >Pattern 1: 0/1 Knapsack</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/"><b>1.0</b> - 0/1 Knapsack</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/equal-subset-sum-partition/"><b>1.1</b> - Equal Subset Sum Partition</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/subset-sum/"><b>1.2</b> - Subset Sum</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/minimum-subset-sum-difference/"><b>1.3</b> - Minimum Subset Sum Difference</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/count-of-subset-sum/"><b>1.4</b> - Count of Subset Sum</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/target-sum/"><b>1.5</b> - Target Sum</a> <div class=course-section >Pattern 2: Unbounded Knapsack</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/"><b>2.0</b> - Unbouned Knapsack</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/rod-cutting/"><b>2.1</b> - Rod Cutting</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/coin-change/"><b>2.2</b> - Coin Change</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/minimum-coin-change/"><b>2.3</b> - Minimum Coin Change</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/maximum-ribbon-cut/"><b>2.4</b> - Maximum Ribbon Cut</a> <div class=course-section >Pattern 3: Fibonacci Numbers</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/"><b>3.0</b> - Fibonacci Numbers</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/staircase/"><b>3.1</b> - Staircase</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/number-factors/"><b>3.2</b> - Number factors</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/minimum-jumps-to-reach-the-end/"><b>3.3</b> - Minimum jumps to reach the end</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/minimum-jumps-with-fee/"><b>3.4</b> - Minimum jumps with fee</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/house-thief/"><b>3.5</b> - House thief</a> <div class=course-section >Pattern 4: Palindromic Subsequence</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/"><b>4.0</b> - Longest Palindromic Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/longest-palindromic-substring/"><b>4.1</b> - Longest Palindromic Substring</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/count-of-palindromic-substrings/"><b>4.2</b> - Count of Palindromic Substrings</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/minimum-deletions-in-a-string-to-make-it-a-palindrome/"><b>4.3</b> - Minimum Deletions in a String to make it a Palindrome</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/palindromic-partitioning/"><b>4.4</b> - Palindromic Partitioning</a> <div class=course-section >Pattern 5: Longest Common Substring</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/"><b>5.0</b> - Longest Common Substring</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-common-subsequence/"><b>5.1</b> - Longest Common Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/minimum-deletions&insertions-to-transform-a-string-into-another/"><b>5.2</b> - Minimum Deletions & Insertions to Transform a String into another</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-increasing-subsequence/"><b>5.3</b> - Longest Increasing Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/maximum-sum-increasing-subsequence/"><b>5.4</b> - Maximum Sum Increasing Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/shortest-common-super-sequence/"><b>5.5</b> - Shortest Common Super-sequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/count-of-palindromic-substrings/"><b>5.6</b> - Minimum Deletions to Make a Sequence Sorted</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-repeating-subsequence/"><b>5.7</b> - Longest Repeating Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/subsequence-pattern-matching/"><b>5.8</b> - Subsequence Pattern Matching</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-bitonic-subsequence/"><b>5.9</b> - Longest Bitonic Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-alternating-subsequence/"><b>5.10</b> - Longest Alternating Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/edit-distance/"><b>5.11</b> - Edit Distance</a> <a class="sidebar-nav-item active" href="/Dynamic-Programming-Patterns/longest-common-substring/strings-interleaving/"><b>5.12</b> - Strings Interleaving</a> <br> </nav> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=strings_interleaving ><a href="#strings_interleaving" class=header-anchor >Strings Interleaving</a></h1> <span style="font-size:24px;font-weight:300;">We'll cover the following</span> <div class=blank ></div> <div class=franklin-toc ><ol><li><a href="#problem_statement">Problem Statement</a><li><a href="#basic_solution">Basic Solution</a><ol><li><a href="#code">Code</a></ol><li><a href="#top-down_dynamic_programming_with_memoization">Top-down Dynamic Programming with Memoization</a><ol><li><a href="#code__2">Code</a></ol><li><a href="#bottom-up_dynamic_programming">Bottom-up Dynamic Programming</a><ol><li><a href="#code__3">Code</a></ol></ol></div> <div class=blank ></div> <h2 id=problem_statement ><a href="#problem_statement" class=header-anchor >Problem Statement</a></h2> <div class="admonition question"> <div class=admonition-title >üôã Question</div> <div class=admonition-content >Give three strings <code>m</code>, <code>n</code>, and <code>p</code>, write a method to find out if <code>p</code> has been formed by interleaving <code>m</code> and <code>n</code>. <code>p</code> would be considered interleaving <code>m</code> and <code>n</code> if it contains all the letters from <code>m</code> and <code>n</code> and the order of letters is preserved too.</div> </div> <ul> <li><p>Example 1</p> </ul> <pre><code class="Plaintext hljs">Input: m=&quot;abd&quot;, n=&quot;cef&quot;, p=&quot;adcbef&quot;
Output: false
Explanation: &#x27;p&#x27; contains all the letters from &#x27;m&#x27; and &#x27;n&#x27; but does not preserve the order.</code></pre> <ul> <li><p>Example 2</p> </ul> <pre><code class="Plaintext hljs">Input: m=&quot;abc&quot;, n=&quot;def&quot;, p=&quot;abdccf&quot;
Output: false
Explanation: &#x27;p&#x27; does not contain all the letters from &#x27;m&#x27; and &#x27;n&#x27;.</code></pre> <ul> <li><p>Example 3</p> </ul> <pre><code class="Plaintext hljs">Input: m=&quot;abcdef&quot;, n=&quot;mnop&quot;, p=&quot;mnaobcdepf&quot;
Output: true
Explanation: &#x27;p&#x27; contains all the letters from &#x27;m&#x27; and &#x27;n&#x27; and preserves their order too.</code></pre> <h2 id=basic_solution ><a href="#basic_solution" class=header-anchor >Basic Solution</a></h2> <p>The problem follows the <a href="/Dynamic-Programming-Patterns/longest-common-substring/longest-common-subsequence/">Longest Common Subsequence</a> &#40;LCS&#41; pattern and has some similarities with <a href="/Dynamic-Programming-Patterns/longest-common-substring/subsequence-pattern-matching/">Subsequence Pattern Matching</a>.</p> <p>A basic brute-force solution could be to try matching <code>m</code> and <code>n</code> with <code>p</code> one letter at a time. Let‚Äô s assume <code>mIndex</code>, <code>nIndex</code>, and <code>pIndex</code> represent the current indexes of <code>m</code>, <code>n</code>, and <code>p</code> strings respectively. Therefore, we have two options at any step:</p> <p>If the letter at <code>mIndex</code> matches with the letter at <code>pIndex</code>, we can recursively match for the remaining lengths of <code>m</code> and <code>p</code>. If the letter at <code>nIndex</code> matches with the letter at <code>‚ÄòpIndex‚Äô</code>, we can recursively match for the remaining lengths of <code>n</code> and <code>p</code>.</p> <h3 id=code ><a href="#code" class=header-anchor >Code</a></h3> <p>Here is the code:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">find_SI</span>(<span class=hljs-params >m, n,  p</span>):
    <span class=hljs-keyword >return</span> find_SI_recursive(m, n, p, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">find_SI_recursive</span>(<span class=hljs-params >m, n, p, mIndex, nIndex, pIndex</span>):

    mLen, nLen, pLen = <span class=hljs-built_in >len</span>(m), <span class=hljs-built_in >len</span>(n), <span class=hljs-built_in >len</span>(p)
    <span class=hljs-comment ># if we have reached the end of the all the strings</span>
    <span class=hljs-keyword >if</span> mIndex == mLen <span class=hljs-keyword >and</span> nIndex == nLen <span class=hljs-keyword >and</span> pIndex == pLen:
        <span class=hljs-keyword >return</span> <span class=hljs-literal >True</span>

    <span class=hljs-comment ># if we have reached the end of &#x27;p&#x27; but &#x27;m&#x27; or &#x27;n&#x27; still has some characters left</span>
    <span class=hljs-keyword >if</span> pIndex == pLen:
        <span class=hljs-keyword >return</span> <span class=hljs-literal >False</span>

    b1, b2 = <span class=hljs-literal >False</span>, <span class=hljs-literal >False</span>
    <span class=hljs-keyword >if</span> mIndex &lt; mLen <span class=hljs-keyword >and</span> m[mIndex] == p[pIndex]:
        b1 = find_SI_recursive(m, n, p, mIndex+<span class=hljs-number >1</span>, nIndex, pIndex+<span class=hljs-number >1</span>)

    <span class=hljs-keyword >if</span> nIndex &lt; nLen <span class=hljs-keyword >and</span> n[nIndex] == p[pIndex]:
        b2 = find_SI_recursive(m, n, p, mIndex, nIndex+<span class=hljs-number >1</span>, pIndex+<span class=hljs-number >1</span>)

    <span class=hljs-keyword >return</span> b1 <span class=hljs-keyword >or</span> b2


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(find_SI(<span class=hljs-string >&quot;abd&quot;</span>, <span class=hljs-string >&quot;cef&quot;</span>, <span class=hljs-string >&quot;abcdef&quot;</span>))
    <span class=hljs-built_in >print</span>(find_SI(<span class=hljs-string >&quot;abd&quot;</span>, <span class=hljs-string >&quot;cef&quot;</span>, <span class=hljs-string >&quot;adcbef&quot;</span>))
    <span class=hljs-built_in >print</span>(find_SI(<span class=hljs-string >&quot;abc&quot;</span>, <span class=hljs-string >&quot;def&quot;</span>, <span class=hljs-string >&quot;abdccf&quot;</span>))
    <span class=hljs-built_in >print</span>(find_SI(<span class=hljs-string >&quot;abcdef&quot;</span>, <span class=hljs-string >&quot;mnop&quot;</span>, <span class=hljs-string >&quot;mnaobcdepf&quot;</span>))


main()</code></pre> <div class="admonition complexity"> <div class=admonition-title >üëâ Complexity</div> <div class=admonition-content >The time complexity of the above algorithm is exponential <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(2^{m+n})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.021331em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> are the lengths of the two interleaving strings. The space complexity is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault">m</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class=mclose >)</span></span></span></span>, the value that is used to store the recursion stack.</div> </div> <h2 id=top-down_dynamic_programming_with_memoization ><a href="#top-down_dynamic_programming_with_memoization" class=header-anchor >Top-down Dynamic Programming with Memoization</a></h2> <p>This problem can have overlapping subproblems only when there are some common letters between <code>m</code> and <code>n</code> at the same index. Because whenever we hit such a scenario, we get an option to match with any one of them.</p> <p>The three changing values in our recursive function are the three indexes <code>mIndex</code>, <code>nIndex</code>, and <code>pIndex</code>. Therefore, we can store the results of all the subproblems in a three-dimensional array. Alternately, we can use a hash-table whose key would be a string &#40;mIndex &#43; ‚Äú|‚Äù &#43; nIndex &#43; ‚Äú|‚Äù &#43; pIndex&#41;.</p> <h3 id=code__2 ><a href="#code__2" class=header-anchor >Code</a></h3> <p>Here is the code for Top-down DP approach:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">find_SI</span>(<span class=hljs-params >m, n, p</span>):
    <span class=hljs-keyword >return</span> find_SI_recursive({}, m, n, p, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">find_SI_recursive</span>(<span class=hljs-params >dp, m, n, p, mIndex, nIndex, pIndex</span>):
    mLen, nLen, pLen = <span class=hljs-built_in >len</span>(m), <span class=hljs-built_in >len</span>(n), <span class=hljs-built_in >len</span>(p)
    <span class=hljs-comment ># if we have reached the end of the all the strings</span>

    <span class=hljs-keyword >if</span> mIndex == mLen <span class=hljs-keyword >and</span> nIndex == nLen <span class=hljs-keyword >and</span> pIndex == pLen:
        <span class=hljs-keyword >return</span> <span class=hljs-literal >True</span>

    <span class=hljs-comment ># if we have reached the end of &#x27;p&#x27; but &#x27;m&#x27; or &#x27;n&#x27; still has some characters left</span>
    <span class=hljs-keyword >if</span> pIndex == pLen:
        <span class=hljs-keyword >return</span> <span class=hljs-literal >False</span>

    subProblemKey = <span class=hljs-built_in >str</span>(mIndex) + <span class=hljs-string >&quot;-&quot;</span> + <span class=hljs-built_in >str</span>(nIndex) + <span class=hljs-string >&quot;-&quot;</span> + <span class=hljs-built_in >str</span>(pIndex)
    <span class=hljs-keyword >if</span> subProblemKey <span class=hljs-keyword >not</span> <span class=hljs-keyword >in</span> dp:
        b1, b2 = <span class=hljs-literal >False</span>, <span class=hljs-literal >False</span>
        <span class=hljs-keyword >if</span> mIndex &lt; mLen <span class=hljs-keyword >and</span> m[mIndex] == p[pIndex]:
            b1 = find_SI_recursive(dp, m, n, p, mIndex + <span class=hljs-number >1</span>, nIndex, pIndex + <span class=hljs-number >1</span>)

        <span class=hljs-keyword >if</span> nIndex &lt; nLen <span class=hljs-keyword >and</span> n[nIndex] == p[pIndex]:
            b2 = find_SI_recursive(dp, m, n, p, mIndex, nIndex + <span class=hljs-number >1</span>, pIndex + <span class=hljs-number >1</span>)

        dp[subProblemKey] = b1 <span class=hljs-keyword >or</span> b2

    <span class=hljs-keyword >return</span> dp.get(subProblemKey)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(find_SI(<span class=hljs-string >&quot;abd&quot;</span>, <span class=hljs-string >&quot;cef&quot;</span>, <span class=hljs-string >&quot;abcdef&quot;</span>))
    <span class=hljs-built_in >print</span>(find_SI(<span class=hljs-string >&quot;abd&quot;</span>, <span class=hljs-string >&quot;cef&quot;</span>, <span class=hljs-string >&quot;adcbef&quot;</span>))
    <span class=hljs-built_in >print</span>(find_SI(<span class=hljs-string >&quot;abc&quot;</span>, <span class=hljs-string >&quot;def&quot;</span>, <span class=hljs-string >&quot;abdccf&quot;</span>))
    <span class=hljs-built_in >print</span>(find_SI(<span class=hljs-string >&quot;abcdef&quot;</span>, <span class=hljs-string >&quot;mnop&quot;</span>, <span class=hljs-string >&quot;mnaobcdepf&quot;</span>))


main()</code></pre> <h2 id=bottom-up_dynamic_programming ><a href="#bottom-up_dynamic_programming" class=header-anchor >Bottom-up Dynamic Programming</a></h2> <p>Since we want to completely match <code>m</code> and <code>n</code> &#40;the two interleaving strings&#41; with <code>p</code>, we can use a two-dimensional array to store our results. The lengths of <code>m</code> and <code>n</code> will define the dimensions of the result array.</p> <p>As mentioned above, we will be tracking separate indexes for <code>m</code>, <code>n</code> and <code>p</code>, so we will have the following options for every value of <code>mIndex</code>, <code>nIndex</code>, and <code>pIndex</code>:</p> <ul> <li><p>If the character <code>m&#91;mIndex&#93;</code> matches the character <code>p&#91;pIndex&#93;</code>, we will take the matching result up to <code>mIndex-1</code> and <code>nIndex</code>.</p> <li><p>If the character <code>n&#91;nIndex&#93;</code> matches the character <code>p&#91;pIndex&#93;</code>, we will take the matching result up to <code>mIndex</code> and <code>nIndex-1</code>.</p> </ul> <p>String <code>p</code> will be interleaving strings <code>m</code> and <code>n</code> if any of the above two options is true. This is also required as there could be some common letters between <code>m</code> and <code>n</code>.</p> <p>So our recursive formula would look like:</p> <pre><code class="python hljs">dp[mIndex][nIndex] = false
<span class=hljs-keyword >if</span> m[mIndex] == p[pIndex] 
    dp[mIndex][nIndex] = dp[mIndex-<span class=hljs-number >1</span>][nIndex]
<span class=hljs-keyword >if</span> n[nIndex] == p[pIndex] 
    dp[mIndex][nIndex] |= dp[mIndex][nIndex-<span class=hljs-number >1</span>]</code></pre> <p>Let‚Äôs draw this visually:</p> <p><img src="/Dynamic-Programming-Patterns/assets/img/longest-common-substring/5.7.png" alt="" /></p> <h3 id=code__3 ><a href="#code__3" class=header-anchor >Code</a></h3> <p>Here is the code for our bottom-up dynamic programming approach:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">find_SI</span>(<span class=hljs-params >m, n, p</span>):
    mLen, nLen, pLen = <span class=hljs-built_in >len</span>(m), <span class=hljs-built_in >len</span>(n), <span class=hljs-built_in >len</span>(p)
    <span class=hljs-comment ># dp[mIndex][nIndex] will be storing the result of string interleaving</span>
    <span class=hljs-comment ># up to p[0..mIndex+nIndex-1]</span>
    dp = [[<span class=hljs-literal >False</span> <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(nLen+<span class=hljs-number >1</span>)] <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(mLen+<span class=hljs-number >1</span>)]

    <span class=hljs-comment ># make sure if lengths of the strings add up</span>
    <span class=hljs-keyword >if</span> mLen + nLen != pLen:
        <span class=hljs-keyword >return</span> <span class=hljs-literal >False</span>

    <span class=hljs-keyword >for</span> mIndex <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(mLen+<span class=hljs-number >1</span>):
        <span class=hljs-keyword >for</span> nIndex <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(nLen+<span class=hljs-number >1</span>):
            <span class=hljs-comment ># if &#x27;m&#x27; and &#x27;n&#x27; are empty, then &#x27;p&#x27; must have been empty too.</span>
            <span class=hljs-keyword >if</span> mIndex == <span class=hljs-number >0</span> <span class=hljs-keyword >and</span> nIndex == <span class=hljs-number >0</span>:
                dp[mIndex][nIndex] = <span class=hljs-literal >True</span>
            <span class=hljs-comment ># if &#x27;m&#x27; is empty, we need to check the interleaving with &#x27;n&#x27; only</span>
            <span class=hljs-keyword >elif</span> mIndex == <span class=hljs-number >0</span> <span class=hljs-keyword >and</span> n[nIndex - <span class=hljs-number >1</span>] == p[mIndex + nIndex - <span class=hljs-number >1</span>]:
                dp[mIndex][nIndex] = dp[mIndex][nIndex - <span class=hljs-number >1</span>]
            <span class=hljs-comment ># if &#x27;n&#x27; is empty, we need to check the interleaving with &#x27;m&#x27; only</span>
            <span class=hljs-keyword >elif</span> nIndex == <span class=hljs-number >0</span> <span class=hljs-keyword >and</span> m[mIndex - <span class=hljs-number >1</span>] == p[mIndex + nIndex - <span class=hljs-number >1</span>]:
                dp[mIndex][nIndex] = dp[mIndex - <span class=hljs-number >1</span>][nIndex]
            <span class=hljs-keyword >else</span>:
                <span class=hljs-comment ># if the letter of &#x27;m&#x27; and &#x27;p&#x27; match, we take whatever is matched till mIndex-1</span>
                <span class=hljs-keyword >if</span> mIndex &gt; <span class=hljs-number >0</span> <span class=hljs-keyword >and</span> m[mIndex - <span class=hljs-number >1</span>] == p[mIndex + nIndex - <span class=hljs-number >1</span>]:
                    dp[mIndex][nIndex] = dp[mIndex - <span class=hljs-number >1</span>][nIndex]
                <span class=hljs-comment ># if the letter of &#x27;n&#x27; and &#x27;p&#x27; match, we take whatever is matched till nIndex-1 too</span>
                <span class=hljs-comment ># note the &#x27;|=&#x27;, this is required when we have common letters</span>
                <span class=hljs-keyword >if</span> nIndex &gt; <span class=hljs-number >0</span> <span class=hljs-keyword >and</span> n[nIndex - <span class=hljs-number >1</span>] == p[mIndex + nIndex - <span class=hljs-number >1</span>]:
                    dp[mIndex][nIndex] |= dp[mIndex][nIndex - <span class=hljs-number >1</span>]

    <span class=hljs-keyword >return</span> dp[mLen][nLen]


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(find_SI(<span class=hljs-string >&quot;abd&quot;</span>, <span class=hljs-string >&quot;cef&quot;</span>, <span class=hljs-string >&quot;abcdef&quot;</span>))
    <span class=hljs-built_in >print</span>(find_SI(<span class=hljs-string >&quot;abd&quot;</span>, <span class=hljs-string >&quot;cef&quot;</span>, <span class=hljs-string >&quot;adcbef&quot;</span>))
    <span class=hljs-built_in >print</span>(find_SI(<span class=hljs-string >&quot;abc&quot;</span>, <span class=hljs-string >&quot;def&quot;</span>, <span class=hljs-string >&quot;abdccf&quot;</span>))
    <span class=hljs-built_in >print</span>(find_SI(<span class=hljs-string >&quot;abcdef&quot;</span>, <span class=hljs-string >&quot;mnop&quot;</span>, <span class=hljs-string >&quot;mnaobcdepf&quot;</span>))


main()</code></pre> <div class="admonition complexity"> <div class=admonition-title >üëâ Complexity</div> <div class=admonition-content >The time and space complexity of the above algorithm is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>m</mi><mo>‚àó</mo><mi>n</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault">m</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >‚àó</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> are the lengths of the two interleaving strings.</div> </div> <div class=page-foot > <div class=copyright > &copy; Qling Alter. Last modified: June 20, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div> </div> <!-- end of class page-wrap-->