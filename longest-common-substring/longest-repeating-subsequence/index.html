<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/libs/katex/katex.min.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/libs/highlight/github.min.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/franklin.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/poole_hyde.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <title>Longest Repeating Subsequence</title> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunr.min.js"></script> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunr_index.js"></script> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunrclient.min.js"></script> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <br> <img src="/Dynamic-Programming-Patterns/assets/infra/DP.svg" style="width: 160px; height: auto; display: inline"> <h1> <div style="line-height:18px; font-size: 20px; opacity: 0.85"><a href="/Dynamic-Programming-Patterns/">Dynamic Programming Patterns</a></div> </h1> <div style="line-height:18px; font-size: 15px; opacity: 0.85">by <a href="https://github.com/rfhklwt">Inia Owlet</a></div> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9"> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/"><b>Overview</b></a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/introduction"><b>Introduction</b></a> <br> <div class=course-section >Pattern 1: 0/1 Knapsack</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/"><b>1.0</b> - 0/1 Knapsack</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/equal-subset-sum-partition/"><b>1.1</b> - Equal Subset Sum Partition</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/subset-sum/"><b>1.2</b> - Subset Sum</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/minimum-subset-sum-difference/"><b>1.3</b> - Minimum Subset Sum Difference</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/count-of-subset-sum/"><b>1.4</b> - Count of Subset Sum</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/target-sum/"><b>1.5</b> - Target Sum</a> <div class=course-section >Pattern 2: Unbounded Knapsack</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/"><b>2.0</b> - Unbouned Knapsack</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/rod-cutting/"><b>2.1</b> - Rod Cutting</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/coin-change/"><b>2.2</b> - Coin Change</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/minimum-coin-change/"><b>2.3</b> - Minimum Coin Change</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/maximum-ribbon-cut/"><b>2.4</b> - Maximum Ribbon Cut</a> <div class=course-section >Pattern 3: Fibonacci Numbers</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/"><b>3.0</b> - Fibonacci Numbers</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/staircase/"><b>3.1</b> - Staircase</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/number-factors/"><b>3.2</b> - Number factors</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/minimum-jumps-to-reach-the-end/"><b>3.3</b> - Minimum jumps to reach the end</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/minimum-jumps-with-fee/"><b>3.4</b> - Minimum jumps with fee</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/house-thief/"><b>3.5</b> - House thief</a> <div class=course-section >Pattern 4: Palindromic Subsequence</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/"><b>4.0</b> - Longest Palindromic Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/longest-palindromic-substring/"><b>4.1</b> - Longest Palindromic Substring</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/count-of-palindromic-substrings/"><b>4.2</b> - Count of Palindromic Substrings</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/minimum-deletions-in-a-string-to-make-it-a-palindrome/"><b>4.3</b> - Minimum Deletions in a String to make it a Palindrome</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/palindromic-partitioning/"><b>4.4</b> - Palindromic Partitioning</a> <div class=course-section >Pattern 5: Longest Common Substring</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/"><b>5.0</b> - Longest Common Substring</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-common-subsequence/"><b>5.1</b> - Longest Common Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/minimum-deletions&insertions-to-transform-a-string-into-another/"><b>5.2</b> - Minimum Deletions & Insertions to Transform a String into another</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-increasing-subsequence/"><b>5.3</b> - Longest Increasing Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/maximum-sum-increasing-subsequence/"><b>5.4</b> - Maximum Sum Increasing Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/shortest-common-super-sequence/"><b>5.5</b> - Shortest Common Super-sequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/count-of-palindromic-substrings/"><b>5.6</b> - Minimum Deletions to Make a Sequence Sorted</a> <a class="sidebar-nav-item active" href="/Dynamic-Programming-Patterns/longest-common-substring/longest-repeating-subsequence/"><b>5.7</b> - Longest Repeating Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/subsequence-pattern-matching/"><b>5.8</b> - Subsequence Pattern Matching</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-bitonic-subsequence/"><b>5.9</b> - Longest Bitonic Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-alternating-subsequence/"><b>5.10</b> - Longest Alternating Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/edit-distance/"><b>5.11</b> - Edit Distance</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/strings-interleaving/"><b>5.12</b> - Strings Interleaving</a> <br> </nav> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=longest_repeating_subsequence ><a href="#longest_repeating_subsequence" class=header-anchor >Longest Repeating Subsequence</a></h1> <span style="font-size:24px;font-weight:300;">We'll cover the following</span> <div class=blank ></div> <div class=franklin-toc ><ol><li><a href="#problem_statement">Problem Statement</a><li><a href="#basic_solution">Basic Solution</a><ol><li><a href="#code">Code</a></ol><li><a href="#top-down_dynamic_programming_with_memoization">Top-down Dynamic Programming with Memoization</a><ol><li><a href="#code__2">Code</a></ol><li><a href="#bottom-up_dynamic_programming">Bottom-up Dynamic Programming</a><ol><li><a href="#code__3">Code</a></ol><li><a href="#next">Next</a></ol></div> <div class=blank ></div> <h2 id=problem_statement ><a href="#problem_statement" class=header-anchor >Problem Statement</a></h2> <div class="admonition question"> <div class=admonition-title >üôã Question</div> <div class=admonition-content >Given a sequence, find the length of its longest repeating subsequence &#40;LRS&#41;. A repeating subsequence will be the one that appears at least twice in the original sequence and is not overlapping &#40;i.e. none of the corresponding characters in the repeating subsequences have the same index&#41;.</div> </div> <ul> <li><p>Example 1</p> </ul> <pre><code class="Plaintext hljs">Input: ‚Äút o m o r r o w‚Äù
Output: 2
Explanation: The longest repeating subsequence is ‚Äúor‚Äù {tomorrow}.</code></pre> <ul> <li><p>Example 2</p> </ul> <pre><code class="Plaintext hljs">Input: ‚Äúa a b d b c e c‚Äù
Output: 3
Explanation: The longest repeating subsequence is ‚Äúa b c‚Äù {a a b d b c e c}.</code></pre> <ul> <li><p>Example 3</p> </ul> <pre><code class="Plaintext hljs">Input: ‚Äúf m f f‚Äù
Output: 2
Explanation: The longest repeating subsequence is ‚Äúf f‚Äù {f m f f, f m f f}. Please note the second last character is shared in LRS.</code></pre> <h2 id=basic_solution ><a href="#basic_solution" class=header-anchor >Basic Solution</a></h2> <p>The problem is quite similar to the <a href="/Dynamic-Programming-Patterns/longest-common-substring/longest-common-subsequence/">Longest Common Subsequence</a> &#40;LCS&#41;, with two differences:</p> <ul> <li><p>In LCS, we were trying to find the longest common subsequence between the two strings, whereas in LRS we are trying to find the two longest common subsequences within one string.</p> <li><p>In LRS, every corresponding character in the subsequences should not have the same index.</p> </ul> <p>A basic brute-force solution could be to try all subsequences of the given sequence to find the longest repeating one, but the problem is how to ensure that the LRS‚Äôs characters do not have the same index. For this, we can start with two indexes in the given sequence, so at any step we have two choices:</p> <ul> <li><p>If the two indexes are not the same and the characters at both the indexes are same, we can recursively match for the remaining length &#40;i.e. by incrementing both the indexes&#41;.</p> <li><p>If the characters at both the indexes don‚Äôt match, we start two new recursive calls by incrementing each index separately. The LRS would be the one with the highest length from the two recursive calls.</p> </ul> <h3 id=code ><a href="#code" class=header-anchor >Code</a></h3> <p>Here is the code:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">find_LRS_length</span>(<span class=hljs-params ><span class=hljs-built_in >str</span></span>):
    <span class=hljs-keyword >return</span> find_LRS_length_recursive(<span class=hljs-built_in >str</span>, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">find_LRS_length_recursive</span>(<span class=hljs-params ><span class=hljs-built_in >str</span>,  i1,  i2</span>):
    <span class=hljs-keyword >if</span> i1 == <span class=hljs-built_in >len</span>(<span class=hljs-built_in >str</span>) <span class=hljs-keyword >or</span> i2 == <span class=hljs-built_in >len</span>(<span class=hljs-built_in >str</span>):
        <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>

    <span class=hljs-keyword >if</span> i1 != i2 <span class=hljs-keyword >and</span> <span class=hljs-built_in >str</span>[i1] == <span class=hljs-built_in >str</span>[i2]:
        <span class=hljs-keyword >return</span> <span class=hljs-number >1</span> + find_LRS_length_recursive(<span class=hljs-built_in >str</span>, i1 + <span class=hljs-number >1</span>, i2 + <span class=hljs-number >1</span>)

    c1 = find_LRS_length_recursive(<span class=hljs-built_in >str</span>, i1, i2 + <span class=hljs-number >1</span>)
    c2 = find_LRS_length_recursive(<span class=hljs-built_in >str</span>, i1 + <span class=hljs-number >1</span>, i2)

    <span class=hljs-keyword >return</span> <span class=hljs-built_in >max</span>(c1, c2)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(find_LRS_length(<span class=hljs-string >&quot;tomorrow&quot;</span>))
    <span class=hljs-built_in >print</span>(find_LRS_length(<span class=hljs-string >&quot;aabdbcec&quot;</span>))
    <span class=hljs-built_in >print</span>(find_LRS_length(<span class=hljs-string >&quot;fmff&quot;</span>))


main()</code></pre> <div class="admonition complexity"> <div class=admonition-title >üëâ Complexity</div> <div class=admonition-content >The time complexity of the above algorithm is exponential <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> is the length of the input sequence. The space complexity is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>n</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault">n</span><span class=mclose >)</span></span></span></span> which is used to store the recursion stack.</div> </div> <h2 id=top-down_dynamic_programming_with_memoization ><a href="#top-down_dynamic_programming_with_memoization" class=header-anchor >Top-down Dynamic Programming with Memoization</a></h2> <p>We can use an array to store the already solved subproblems.</p> <p>The two changing values to our recursive function are the two indexes, i1 and i2. Therefore, we can store the results of all the subproblems in a two-dimensional array. &#40;Another alternative could be to use a hash-table whose key would be a string &#40;i1 &#43; ‚Äú|‚Äù &#43; i2&#41;&#41;.</p> <h3 id=code__2 ><a href="#code__2" class=header-anchor >Code</a></h3> <p>Here is the code:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">find_LRS_length</span>(<span class=hljs-params ><span class=hljs-built_in >str</span></span>):
    n = <span class=hljs-built_in >len</span>(<span class=hljs-built_in >str</span>)
    dp = [[-<span class=hljs-number >1</span> <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n)] <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n)]
    <span class=hljs-keyword >return</span> find_LRS_length_recursive(dp, <span class=hljs-built_in >str</span>, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">find_LRS_length_recursive</span>(<span class=hljs-params >dp,  <span class=hljs-built_in >str</span>, i1, i2</span>):
    n = <span class=hljs-built_in >len</span>(<span class=hljs-built_in >str</span>)
    <span class=hljs-keyword >if</span> i1 == n <span class=hljs-keyword >or</span> i2 == n:
        <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>

    <span class=hljs-keyword >if</span> dp[i1][i2] == -<span class=hljs-number >1</span>:
        <span class=hljs-keyword >if</span> i1 != i2 <span class=hljs-keyword >and</span> <span class=hljs-built_in >str</span>[i1] == <span class=hljs-built_in >str</span>[i2]:
            dp[i1][i2] = <span class=hljs-number >1</span> + find_LRS_length_recursive(dp, <span class=hljs-built_in >str</span>, i1 + <span class=hljs-number >1</span>, i2 + <span class=hljs-number >1</span>)
        <span class=hljs-keyword >else</span>:
            c1 = find_LRS_length_recursive(dp, <span class=hljs-built_in >str</span>, i1, i2 + <span class=hljs-number >1</span>)
            c2 = find_LRS_length_recursive(dp, <span class=hljs-built_in >str</span>, i1 + <span class=hljs-number >1</span>, i2)
            dp[i1][i2] = <span class=hljs-built_in >max</span>(c1, c2)

    <span class=hljs-keyword >return</span> dp[i1][i2]


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(find_LRS_length(<span class=hljs-string >&quot;tomorrow&quot;</span>))
    <span class=hljs-built_in >print</span>(find_LRS_length(<span class=hljs-string >&quot;aabdbcec&quot;</span>))
    <span class=hljs-built_in >print</span>(find_LRS_length(<span class=hljs-string >&quot;fmff&quot;</span>))


main()</code></pre> <h2 id=bottom-up_dynamic_programming ><a href="#bottom-up_dynamic_programming" class=header-anchor >Bottom-up Dynamic Programming</a></h2> <p>Since we want to match all the subsequences of the given string, we can use a two-dimensional array to store our results. As mentioned above, we will be tracking two indexes to overcome the overlapping problem. So for each of the two indexes, <code>i1</code> and <code>i2</code>, we will choose one of the following options:</p> <ul> <li><p>If <code>i1</code> and <code>i2</code> are different and the character <code>str&#91;i1&#93;</code> matches the character <code>str&#91;i2&#93;</code>, then the length of the LRS would be one plus the length of LRS up to <code>i1-1</code> and <code>i2-1</code> indexes.</p> <li><p>If the character at <code>str&#91;i1&#93;</code> does not match <code>str&#91;i2&#93;</code>, we will take the LRS by either skipping <code>i1</code>th or <code>i2</code>th character.</p> </ul> <p>So our recursive formula would be:</p> <pre><code class="python hljs"><span class=hljs-keyword >if</span> i1 != i2 &amp;&amp; <span class=hljs-built_in >str</span>[i1] == <span class=hljs-built_in >str</span>[i2] 
    dp[i1][i2] = <span class=hljs-number >1</span> + dp[i1-<span class=hljs-number >1</span>][i2-<span class=hljs-number >1</span>]
<span class=hljs-keyword >else</span> 
    dp[i1][i2] = <span class=hljs-built_in >max</span>(dp[i1-<span class=hljs-number >1</span>][i2], dp[i1][i2-<span class=hljs-number >1</span>])</code></pre> <h3 id=code__3 ><a href="#code__3" class=header-anchor >Code</a></h3> <p>Here is the code for our bottom-up dynamic programming approach:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">find_LRS_length</span>(<span class=hljs-params ><span class=hljs-built_in >str</span></span>):
    n = <span class=hljs-built_in >len</span>(<span class=hljs-built_in >str</span>)
    dp = [[<span class=hljs-number >0</span> <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n+<span class=hljs-number >1</span>)] <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n+<span class=hljs-number >1</span>)]
    maxLength = <span class=hljs-number >0</span>
    <span class=hljs-comment ># dp[i1][i2] will be storing the LRS up to str[0..i1-1][0..i2-1]</span>
    <span class=hljs-comment ># this also means that subsequences of length zero(first row and column of</span>
    <span class=hljs-comment ># dp[][]), will always have LRS of size zero.</span>
    <span class=hljs-keyword >for</span> i1 <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >1</span>, n+<span class=hljs-number >1</span>):
        <span class=hljs-keyword >for</span> i2 <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >1</span>, n+<span class=hljs-number >1</span>):
            <span class=hljs-keyword >if</span> i1 != i2 <span class=hljs-keyword >and</span> <span class=hljs-built_in >str</span>[i1 - <span class=hljs-number >1</span>] == <span class=hljs-built_in >str</span>[i2 - <span class=hljs-number >1</span>]:
                dp[i1][i2] = <span class=hljs-number >1</span> + dp[i1 - <span class=hljs-number >1</span>][i2 - <span class=hljs-number >1</span>]
            <span class=hljs-keyword >else</span>:
                dp[i1][i2] = <span class=hljs-built_in >max</span>(dp[i1 - <span class=hljs-number >1</span>][i2], dp[i1][i2 - <span class=hljs-number >1</span>])

            maxLength = <span class=hljs-built_in >max</span>(maxLength, dp[i1][i2])

    <span class=hljs-keyword >return</span> maxLength


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(find_LRS_length(<span class=hljs-string >&quot;tomorrow&quot;</span>))
    <span class=hljs-built_in >print</span>(find_LRS_length(<span class=hljs-string >&quot;aabdbcec&quot;</span>))
    <span class=hljs-built_in >print</span>(find_LRS_length(<span class=hljs-string >&quot;fmff&quot;</span>))


main()</code></pre> <div class="admonition complexity"> <div class=admonition-title >üëâ Complexity</div> <div class=admonition-content >The time and space complexity of the above algorithm is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathdefault">n</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> is the length of the input sequence.</div> </div> <h2 id=next ><a href="#next" class=header-anchor >Next</a></h2> <div class=flist ><ul> <li><p><a href="/Dynamic-Programming-Patterns/longest-common-substring/subsequence-pattern-matching" id=goto ><span id=check >&check;</span><span id=arrow ><b>&rarr;</b></span></a> Subsequence Pattern Matching</p> </ul></div> <div class=page-foot > <div class=copyright > &copy; Qling Alter. Last modified: June 20, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div> </div> <!-- end of class page-wrap-->