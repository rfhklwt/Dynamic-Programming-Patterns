<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/libs/katex/katex.min.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/libs/highlight/github.min.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/franklin.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/poole_hyde.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <title>Longest Repeating Subsequence</title> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunr.min.js"></script> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunr_index.js"></script> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunrclient.min.js"></script> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <br> <img src="/Dynamic-Programming-Patterns/assets/infra/DP.svg" style="width: 160px; height: auto; display: inline"> <h1> <div style="line-height:18px; font-size: 20px; opacity: 0.85"><a href="/Dynamic-Programming-Patterns/">Dynamic Programming Patterns</a></div> </h1> <div style="line-height:18px; font-size: 15px; opacity: 0.85">by <a href="https://github.com/rfhklwt">Inia Owlet</a></div> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9"> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/"><b>Overview</b></a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/introduction"><b>Introduction</b></a> <br> <div class=course-section >Pattern 1: 0/1 Knapsack</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/"><b>1.0</b> - 0/1 Knapsack</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/equal-subset-sum-partition/"><b>1.1</b> - Equal Subset Sum Partition</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/subset-sum/"><b>1.2</b> - Subset Sum</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/minimum-subset-sum-difference/"><b>1.3</b> - Minimum Subset Sum Difference</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/count-of-subset-sum/"><b>1.4</b> - Count of Subset Sum</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/target-sum/"><b>1.5</b> - Target Sum</a> <div class=course-section >Pattern 2: Unbounded Knapsack</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/"><b>2.0</b> - Unbouned Knapsack</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/rod-cutting/"><b>2.1</b> - Rod Cutting</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/coin-change/"><b>2.2</b> - Coin Change</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/minimum-coin-change/"><b>2.3</b> - Minimum Coin Change</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/maximum-ribbon-cut/"><b>2.4</b> - Maximum Ribbon Cut</a> <div class=course-section >Pattern 3: Fibonacci Numbers</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/"><b>3.0</b> - Fibonacci Numbers</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/staircase/"><b>3.1</b> - Staircase</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/number-factors/"><b>3.2</b> - Number factors</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/minimum-jumps-to-reach-the-end/"><b>3.3</b> - Minimum jumps to reach the end</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/minimum-jumps-with-fee/"><b>3.4</b> - Minimum jumps with fee</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/house-thief/"><b>3.5</b> - House thief</a> <div class=course-section >Pattern 4: Palindromic Subsequence</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/"><b>4.0</b> - Longest Palindromic Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/longest-palindromic-substring/"><b>4.1</b> - Longest Palindromic Substring</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/count-of-palindromic-substrings/"><b>4.2</b> - Count of Palindromic Substrings</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/minimum-deletions-in-a-string-to-make-it-a-palindrome/"><b>4.3</b> - Minimum Deletions in a String to make it a Palindrome</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/palindromic-partitioning/"><b>4.4</b> - Palindromic Partitioning</a> <div class=course-section >Pattern 5: Longest Common Substring</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/"><b>5.0</b> - Longest Common Substring</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-common-subsequence/"><b>5.1</b> - Longest Common Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/minimum-deletions&insertions-to-transform-a-string-into-another/"><b>5.2</b> - Minimum Deletions & Insertions to Transform a String into another</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-increasing-subsequence/"><b>5.3</b> - Longest Increasing Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/maximum-sum-increasing-subsequence/"><b>5.4</b> - Maximum Sum Increasing Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/shortest-common-super-sequence/"><b>5.5</b> - Shortest Common Super-sequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/count-of-palindromic-substrings/"><b>5.6</b> - Minimum Deletions to Make a Sequence Sorted</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-repeating-subsequence/"><b>5.7</b> - Longest Repeating Subsequence</a> <a class="sidebar-nav-item active" href="/Dynamic-Programming-Patterns/longest-common-substring/subsequence-pattern-matching/"><b>5.8</b> - Subsequence Pattern Matching</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-bitonic-subsequence/"><b>5.9</b> - Longest Bitonic Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-alternating-subsequence/"><b>5.10</b> - Longest Alternating Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/edit-distance/"><b>5.11</b> - Edit Distance</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/strings-interleaving/"><b>5.12</b> - Strings Interleaving</a> <br> </nav> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=longest_repeating_subsequence ><a href="#longest_repeating_subsequence" class=header-anchor >Longest Repeating Subsequence</a></h1> <span style="font-size:24px;font-weight:300;">We'll cover the following</span> <div class=blank ></div> <div class=franklin-toc ><ol><li><a href="#problem_statement">Problem Statement</a><li><a href="#basic_solution">Basic Solution</a><ol><li><a href="#code">Code</a></ol><li><a href="#top-down_dynamic_programming_with_memoization">Top-down Dynamic Programming with Memoization</a><ol><li><a href="#code__2">Code</a></ol><li><a href="#bottom-up_dynamic_programming">Bottom-up Dynamic Programming</a><ol><li><a href="#code__3">Code</a></ol><li><a href="#next">Next</a></ol></div> <div class=blank ></div> <h2 id=problem_statement ><a href="#problem_statement" class=header-anchor >Problem Statement</a></h2> <div class="admonition question"> <div class=admonition-title >üôã Question</div> <div class=admonition-content >Given a string and a pattern, write a method to count the number of times the pattern appears in the string as a subsequence.</div> </div> <ul> <li><p>Example 1</p> </ul> <pre><code class="Plaintext hljs">Example 1: Input: string: ‚Äúbaxmx‚Äù, pattern: ‚Äúax‚Äù
Output: 2
Explanation: {baxmx, baxmx}.</code></pre> <ul> <li><p>Example 2</p> </ul> <pre><code class="Plaintext hljs">Input: string: ‚Äútomorrow‚Äù, pattern: ‚Äútor‚Äù
Output: 4
Explanation: Following are the four occurences: {tomorrow, tomorrow, tomorrow, tomorrow}.</code></pre> <h2 id=basic_solution ><a href="#basic_solution" class=header-anchor >Basic Solution</a></h2> <p>This problem follows the <a href="/Dynamic-Programming-Patterns/longest-common-substring/longest-common-subsequence/">Longest Common Subsequence</a> &#40;LCS&#41; pattern and is quite similar to the <a href="/Dynamic-Programming-Patterns/longest-common-substring/longest-repeating-subsequence/">Longest Repeating Subsequence</a>; the difference is that we need to count the total occurrences of the subsequence.</p> <p>A basic brute-force solution could be to try all the subsequences of the given string to count all that match the given pattern. We can match the pattern with the given string one character at a time, so we can do two things at any step:</p> <ul> <li><p>If the pattern has a matching character with the string, we can recursively match for the remaining lengths of the pattern and the string.</p> <li><p>At every step, we can always skip a character from the string to try to match the remaining string with the pattern. So we can start a recursive call by skipping one character from the string.</p> </ul> <p>Our total count will be the sum of the counts returned by the above two options.</p> <h3 id=code ><a href="#code" class=header-anchor >Code</a></h3> <p>Here is the code:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">find_SPM_count</span>(<span class=hljs-params ><span class=hljs-built_in >str</span>, pat</span>):
    <span class=hljs-keyword >return</span> find_SPM_count_recursive(<span class=hljs-built_in >str</span>, pat, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">find_SPM_count_recursive</span>(<span class=hljs-params ><span class=hljs-built_in >str</span>,  pat,  strIndex,  patIndex</span>):

    <span class=hljs-comment ># if we have reached the end of the pattern</span>
    <span class=hljs-keyword >if</span> patIndex == <span class=hljs-built_in >len</span>(pat):
        <span class=hljs-keyword >return</span> <span class=hljs-number >1</span>

    <span class=hljs-comment ># if we have reached the end of the string but pattern has still some characters left</span>
    <span class=hljs-keyword >if</span> strIndex == <span class=hljs-built_in >len</span>(<span class=hljs-built_in >str</span>):
        <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>

    c1 = <span class=hljs-number >0</span>
    <span class=hljs-keyword >if</span> <span class=hljs-built_in >str</span>[strIndex] == pat[patIndex]:
        c1 = find_SPM_count_recursive(<span class=hljs-built_in >str</span>, pat, strIndex + <span class=hljs-number >1</span>, patIndex + <span class=hljs-number >1</span>)

    c2 = find_SPM_count_recursive(<span class=hljs-built_in >str</span>, pat, strIndex + <span class=hljs-number >1</span>, patIndex)

    <span class=hljs-keyword >return</span> c1 + c2


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(find_SPM_count(<span class=hljs-string >&quot;baxmx&quot;</span>, <span class=hljs-string >&quot;ax&quot;</span>))
    <span class=hljs-built_in >print</span>(find_SPM_count(<span class=hljs-string >&quot;tomorrow&quot;</span>, <span class=hljs-string >&quot;tor&quot;</span>))


main()</code></pre> <div class="admonition complexity"> <div class=admonition-title >üëâ Complexity</div> <div class=admonition-content >The time complexity of the above algorithm is exponential O<span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><msup><mn>2</mn><mi>m</mi></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(2^{m})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> is the length of the string, as our recursion stack will not be deeper than <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>. The space complexity is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>m</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault">m</span><span class=mclose >)</span></span></span></span> which is used to store the recursion stack.</div> </div> <h2 id=top-down_dynamic_programming_with_memoization ><a href="#top-down_dynamic_programming_with_memoization" class=header-anchor >Top-down Dynamic Programming with Memoization</a></h2> <p>We can use an array to store the already solved subproblems.</p> <p>The two changing values to our recursive function are the two indexes <code>strIndex</code> and <code>patIndex</code>. Therefore, we can store the results of all the subproblems in a two-dimensional array. &#40;Another alternative could be to use a hash-table whose key would be a string &#40;strIndex &#43; ‚Äú|‚Äù &#43; patIndex&#41;&#41;.</p> <h3 id=code__2 ><a href="#code__2" class=header-anchor >Code</a></h3> <p>Here is the code:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">find_SPM_count</span>(<span class=hljs-params ><span class=hljs-built_in >str</span>, pat</span>):
    dp = [[-<span class=hljs-number >1</span> <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-built_in >len</span>(pat))] <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-built_in >len</span>(<span class=hljs-built_in >str</span>))]
    <span class=hljs-keyword >return</span> find_SPM_count_recursive(dp, <span class=hljs-built_in >str</span>, pat, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">find_SPM_count_recursive</span>(<span class=hljs-params >dp, <span class=hljs-built_in >str</span>, pat, strIndex, patIndex</span>):

    <span class=hljs-comment ># if we have reached the end of the pattern</span>
    <span class=hljs-keyword >if</span> patIndex == <span class=hljs-built_in >len</span>(pat):
        <span class=hljs-keyword >return</span> <span class=hljs-number >1</span>

    <span class=hljs-comment ># if we have reached the end of the string but pattern has still some characters left</span>
    <span class=hljs-keyword >if</span> strIndex == <span class=hljs-built_in >len</span>(<span class=hljs-built_in >str</span>):
        <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>

    <span class=hljs-keyword >if</span> dp[strIndex][patIndex] == -<span class=hljs-number >1</span>:
        c1 = <span class=hljs-number >0</span>
        <span class=hljs-keyword >if</span> <span class=hljs-built_in >str</span>[strIndex] == pat[patIndex]:
            c1 = find_SPM_count_recursive(
                dp, <span class=hljs-built_in >str</span>, pat, strIndex + <span class=hljs-number >1</span>, patIndex + <span class=hljs-number >1</span>)
        c2 = find_SPM_count_recursive(dp, <span class=hljs-built_in >str</span>, pat, strIndex + <span class=hljs-number >1</span>, patIndex)
        dp[strIndex][patIndex] = c1 + c2

    <span class=hljs-keyword >return</span> dp[strIndex][patIndex]


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(find_SPM_count(<span class=hljs-string >&quot;baxmx&quot;</span>, <span class=hljs-string >&quot;ax&quot;</span>))
    <span class=hljs-built_in >print</span>(find_SPM_count(<span class=hljs-string >&quot;tomorrow&quot;</span>, <span class=hljs-string >&quot;tor&quot;</span>))


main()</code></pre> <h2 id=bottom-up_dynamic_programming ><a href="#bottom-up_dynamic_programming" class=header-anchor >Bottom-up Dynamic Programming</a></h2> <p>Since we want to match all the subsequences of the given string, we can use a two-dimensional array to store our results. As mentioned above, we will be tracking separate indexes for the string and the pattern, so we will be doing two things for every value of <code>strIndex</code> and <code>patIndex</code>:</p> <ul> <li><p>If the character at the <code>strIndex</code> &#40;in the string&#41; matches the character at <code>patIndex</code> &#40;in the pattern&#41;, the count of the SPM would be equal to the count of SPM up to <code>strIndex-1</code> and <code>patIndex-1</code>.</p> <li><p>At every step, we can always skip a character from the string to try matching the remaining string with the pattern; therefore, we can add the SPM count from the indexes <code>strIndex-1</code> and <code>patIndex</code>.</p> </ul> <p>So our recursive formula would be:</p> <pre><code class="python hljs"><span class=hljs-keyword >if</span> <span class=hljs-built_in >str</span>[strIndex] == pat[patIndex] {
    dp[strIndex][patIndex] = dp[strIndex-<span class=hljs-number >1</span>][patIndex-<span class=hljs-number >1</span>]
}
    dp[strIndex][patIndex] += dp[strIndex-<span class=hljs-number >1</span>][patIndex]</code></pre> <h3 id=code__3 ><a href="#code__3" class=header-anchor >Code</a></h3> <p>Here is the code for our bottom-up dynamic programming approach:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">find_SPM_count</span>(<span class=hljs-params ><span class=hljs-built_in >str</span>, pat</span>):
    strLen, patLen = <span class=hljs-built_in >len</span>(<span class=hljs-built_in >str</span>), <span class=hljs-built_in >len</span>(pat)
    <span class=hljs-comment ># every empty pattern has one match</span>
    <span class=hljs-keyword >if</span> patLen == <span class=hljs-number >0</span>:
        <span class=hljs-keyword >return</span> <span class=hljs-number >1</span>

    <span class=hljs-keyword >if</span> strLen == <span class=hljs-number >0</span> <span class=hljs-keyword >or</span> patLen &gt; strLen:
        <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>

    <span class=hljs-comment ># dp[strIndex][patIndex] will be storing the count of SPM up to str[0..strIndex-1][0..patIndex-1]</span>
    dp = [[<span class=hljs-number >0</span> <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(patLen+<span class=hljs-number >1</span>)] <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(strLen+<span class=hljs-number >1</span>)]

    <span class=hljs-comment ># for the empty pattern, we have one matching</span>
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(strLen+<span class=hljs-number >1</span>):
        dp[i][<span class=hljs-number >0</span>] = <span class=hljs-number >1</span>

    <span class=hljs-keyword >for</span> strIndex <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >1</span>, strLen+<span class=hljs-number >1</span>):
        <span class=hljs-keyword >for</span> patIndex <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >1</span>, patLen+<span class=hljs-number >1</span>):
            <span class=hljs-keyword >if</span> <span class=hljs-built_in >str</span>[strIndex - <span class=hljs-number >1</span>] == pat[patIndex - <span class=hljs-number >1</span>]:
                dp[strIndex][patIndex] = dp[strIndex - <span class=hljs-number >1</span>][patIndex - <span class=hljs-number >1</span>]
            dp[strIndex][patIndex] += dp[strIndex - <span class=hljs-number >1</span>][patIndex]

    <span class=hljs-keyword >return</span> dp[strLen][patLen]


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(find_SPM_count(<span class=hljs-string >&quot;baxmx&quot;</span>, <span class=hljs-string >&quot;ax&quot;</span>))
    <span class=hljs-built_in >print</span>(find_SPM_count(<span class=hljs-string >&quot;tomorrow&quot;</span>, <span class=hljs-string >&quot;tor&quot;</span>))


main()</code></pre> <div class="admonition complexity"> <div class=admonition-title >üëâ Complexity</div> <div class=admonition-content >The time and space complexity of the above algorithm is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>m</mi><mo>‚àó</mo><mi>n</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault">m</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >‚àó</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> are the lengths of the string and the pattern respectively.</div> </div> <h2 id=next ><a href="#next" class=header-anchor >Next</a></h2> <div class=flist ><ul> <li><p><a href="/Dynamic-Programming-Patterns/longest-common-substring/longest-bitonic-subsequence" id=goto ><span id=check >&check;</span><span id=arrow ><b>&rarr;</b></span></a> Longest Bitonic Subsequence</p> </ul></div> <div class=page-foot > <div class=copyright > &copy; Qling Alter. Last modified: June 20, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div> </div> <!-- end of class page-wrap-->