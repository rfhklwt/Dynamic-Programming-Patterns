<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/libs/katex/katex.min.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/libs/highlight/github.min.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/franklin.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/poole_hyde.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <title>Edit Distance</title> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunr.min.js"></script> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunr_index.js"></script> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunrclient.min.js"></script> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <br> <img src="/Dynamic-Programming-Patterns/assets/infra/DP.svg" style="width: 160px; height: auto; display: inline"> <h1> <div style="line-height:18px; font-size: 20px; opacity: 0.85"><a href="/Dynamic-Programming-Patterns/">Dynamic Programming Patterns</a></div> </h1> <div style="line-height:18px; font-size: 15px; opacity: 0.85">by <a href="https://github.com/rfhklwt">Inia Owlet</a></div> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9"> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/"><b>Overview</b></a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/introduction"><b>Introduction</b></a> <br> <div class=course-section >Pattern 1: 0/1 Knapsack</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/"><b>1.0</b> - 0/1 Knapsack</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/equal-subset-sum-partition/"><b>1.1</b> - Equal Subset Sum Partition</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/subset-sum/"><b>1.2</b> - Subset Sum</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/minimum-subset-sum-difference/"><b>1.3</b> - Minimum Subset Sum Difference</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/count-of-subset-sum/"><b>1.4</b> - Count of Subset Sum</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/target-sum/"><b>1.5</b> - Target Sum</a> <div class=course-section >Pattern 2: Unbounded Knapsack</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/"><b>2.0</b> - Unbouned Knapsack</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/rod-cutting/"><b>2.1</b> - Rod Cutting</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/coin-change/"><b>2.2</b> - Coin Change</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/minimum-coin-change/"><b>2.3</b> - Minimum Coin Change</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/maximum-ribbon-cut/"><b>2.4</b> - Maximum Ribbon Cut</a> <div class=course-section >Pattern 3: Fibonacci Numbers</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/"><b>3.0</b> - Fibonacci Numbers</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/staircase/"><b>3.1</b> - Staircase</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/number-factors/"><b>3.2</b> - Number factors</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/minimum-jumps-to-reach-the-end/"><b>3.3</b> - Minimum jumps to reach the end</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/minimum-jumps-with-fee/"><b>3.4</b> - Minimum jumps with fee</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/house-thief/"><b>3.5</b> - House thief</a> <div class=course-section >Pattern 4: Palindromic Subsequence</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/"><b>4.0</b> - Longest Palindromic Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/longest-palindromic-substring/"><b>4.1</b> - Longest Palindromic Substring</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/count-of-palindromic-substrings/"><b>4.2</b> - Count of Palindromic Substrings</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/minimum-deletions-in-a-string-to-make-it-a-palindrome/"><b>4.3</b> - Minimum Deletions in a String to make it a Palindrome</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/palindromic-partitioning/"><b>4.4</b> - Palindromic Partitioning</a> <div class=course-section >Pattern 5: Longest Common Substring</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/"><b>5.0</b> - Longest Common Substring</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-common-subsequence/"><b>5.1</b> - Longest Common Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/minimum-deletions&insertions-to-transform-a-string-into-another/"><b>5.2</b> - Minimum Deletions & Insertions to Transform a String into another</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-increasing-subsequence/"><b>5.3</b> - Longest Increasing Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/maximum-sum-increasing-subsequence/"><b>5.4</b> - Maximum Sum Increasing Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/shortest-common-super-sequence/"><b>5.5</b> - Shortest Common Super-sequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/minimum-deletions-to-make-a-sequence-sorted/"><b>5.6</b> - Minimum Deletions to Make a Sequence Sorted</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-repeating-subsequence/"><b>5.7</b> - Longest Repeating Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/subsequence-pattern-matching/"><b>5.8</b> - Subsequence Pattern Matching</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-bitonic-subsequence/"><b>5.9</b> - Longest Bitonic Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-alternating-subsequence/"><b>5.10</b> - Longest Alternating Subsequence</a> <a class="sidebar-nav-item active" href="/Dynamic-Programming-Patterns/longest-common-substring/edit-distance/"><b>5.11</b> - Edit Distance</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/strings-interleaving/"><b>5.12</b> - Strings Interleaving</a> <br> </nav> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=edit_distance ><a href="#edit_distance" class=header-anchor >Edit Distance</a></h1> <span style="font-size:24px;font-weight:300;">We'll cover the following</span> <div class=blank ></div> <div class=franklin-toc ><ol><li><a href="#problem_statement">Problem Statement</a><li><a href="#basic_solution">Basic Solution</a><ol><li><a href="#code">Code</a></ol><li><a href="#top-down_dynamic_programming_with_memoization">Top-down Dynamic Programming with Memoization</a><ol><li><a href="#code__2">Code</a></ol><li><a href="#bottom-up_dynamic_programming">Bottom-up Dynamic Programming</a><ol><li><a href="#code__3">Code</a></ol><li><a href="#next">Next</a></ol></div> <div class=blank ></div> <h2 id=problem_statement ><a href="#problem_statement" class=header-anchor >Problem Statement</a></h2> <div class="admonition question"> <div class=admonition-title >üôã Question</div> <div class=admonition-content >Given strings s1 and s2, we need to transform s1 into s2 by deleting, inserting, or replacing characters. Write a function to calculate the count of the minimum number of edit operations.</div> </div> <ul> <li><p>Example 1</p> </ul> <pre><code class="Plaintext hljs">Input: s1 = &quot;bat&quot;
       s2 = &quot;but&quot;
Output: 1
Explanation: We just need to replace &#x27;a&#x27; with &#x27;u&#x27; to transform s1 to s2.</code></pre> <ul> <li><p>Example 2</p> </ul> <pre><code class="Plaintext hljs">Input: s1 = &quot;abdca&quot;
       s2 = &quot;cbda&quot;
Output: 2
Explanation: We can replace first &#x27;a&#x27; with &#x27;c&#x27; and delete second &#x27;c&#x27;.</code></pre> <ul> <li><p>Example 3</p> </ul> <pre><code class="Plaintext hljs">Input: s1 = &quot;passpot&quot;
       s2 = &quot;ppsspqrt&quot;
Output: 3 
Explanation: Replace &#x27;a&#x27; with &#x27;p&#x27;, &#x27;o&#x27; with &#x27;q&#x27;, and insert &#x27;r&#x27;.</code></pre> <h2 id=basic_solution ><a href="#basic_solution" class=header-anchor >Basic Solution</a></h2> <p>A basic brute-force solution could be to try all operations &#40;one by one&#41; on each character of s1. We can iterate through s1 and s2 together. Let‚Äôs assume index1 and index2 point to the current indexes of s1 and s2 respectively, so we have two options at every step:</p> <ul> <li><p>If the strings have a matching character, we can recursively match for the remaining lengths.</p> <li><p>If the strings don‚Äôt match, we start three new recursive calls representing the three edit operations. Whichever recursive call returns the minimum count of operations will be our answer.</p> </ul> <h3 id=code ><a href="#code" class=header-anchor >Code</a></h3> <p>Here is the recursive implementation:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">find_min_operations</span>(<span class=hljs-params >s1, s2</span>):
    <span class=hljs-keyword >return</span> find_min_operations_recursive(s1, s2, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">find_min_operations_recursive</span>(<span class=hljs-params >s1, s2, i1, i2</span>):

    n1, n2 = <span class=hljs-built_in >len</span>(s1), <span class=hljs-built_in >len</span>(s2)
    <span class=hljs-comment ># if we have reached the end of s1, then we have to insert all the remaining characters of s2</span>
    <span class=hljs-keyword >if</span> i1 == n1:
        <span class=hljs-keyword >return</span> n2 - i2

    <span class=hljs-comment ># if we have reached the end of s2, then we have to delete all the remaining characters of s1</span>
    <span class=hljs-keyword >if</span> i2 == n2:
        <span class=hljs-keyword >return</span> n1 - i1

    <span class=hljs-comment ># If the strings have a matching character, we can recursively match for the remaining lengths</span>
    <span class=hljs-keyword >if</span> s1[i1] == s2[i2]:
        <span class=hljs-keyword >return</span> find_min_operations_recursive(s1, s2, i1 + <span class=hljs-number >1</span>, i2 + <span class=hljs-number >1</span>)

    <span class=hljs-comment ># perform deletion</span>
    c1 = <span class=hljs-number >1</span> + find_min_operations_recursive(s1, s2, i1 + <span class=hljs-number >1</span>, i2)
    <span class=hljs-comment ># perform insertion</span>
    c2 = <span class=hljs-number >1</span> + find_min_operations_recursive(s1, s2, i1, i2 + <span class=hljs-number >1</span>)
    <span class=hljs-comment ># perform replacement</span>
    c3 = <span class=hljs-number >1</span> + find_min_operations_recursive(s1, s2, i1 + <span class=hljs-number >1</span>, i2 + <span class=hljs-number >1</span>)

    <span class=hljs-keyword >return</span> <span class=hljs-built_in >min</span>(c1, <span class=hljs-built_in >min</span>(c2, c3))


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(find_min_operations(<span class=hljs-string >&quot;bat&quot;</span>, <span class=hljs-string >&quot;but&quot;</span>))
    <span class=hljs-built_in >print</span>(find_min_operations(<span class=hljs-string >&quot;abdca&quot;</span>, <span class=hljs-string >&quot;cbda&quot;</span>))
    <span class=hljs-built_in >print</span>(find_min_operations(<span class=hljs-string >&quot;passpot&quot;</span>, <span class=hljs-string >&quot;ppsspqrt&quot;</span>))


main()</code></pre> <div class="admonition complexity"> <div class=admonition-title >üëâ Complexity</div> <div class=admonition-content >Because of the three recursive calls, the time complexity of the above algorithm is exponential <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mn>3</mn><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(3^{m+n})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.021331em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class=mord >3</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> are the lengths of the two input strings. The space complexity is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault">n</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class=mclose >)</span></span></span></span> which is used to store the recursion stack.</div> </div> <h2 id=top-down_dynamic_programming_with_memoization ><a href="#top-down_dynamic_programming_with_memoization" class=header-anchor >Top-down Dynamic Programming with Memoization</a></h2> <p>We can use an array to store the already solved subproblems.</p> <p>The two changing values in our recursive function are the two indexes, i1 and i2. Therefore, we can store the results of all the subproblems in a two-dimensional array. &#40;Another alternative could be to use a hash-table whose key would be a string &#40;i1 &#43; ‚Äú|‚Äù &#43; i2&#41;&#41;.</p> <h3 id=code__2 ><a href="#code__2" class=header-anchor >Code</a></h3> <p>Here is the code for Top-down DP approach:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">find_min_operations</span>(<span class=hljs-params >s1, s2</span>):
    dp = [[-<span class=hljs-number >1</span> <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-built_in >len</span>(s2)+<span class=hljs-number >1</span>)] <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-built_in >len</span>(s1)+<span class=hljs-number >1</span>)]
    <span class=hljs-keyword >return</span> find_min_operations_recursive(dp, s1, s2, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">find_min_operations_recursive</span>(<span class=hljs-params >dp, s1,  s2,  i1,  i2</span>):
    n1, n2 = <span class=hljs-built_in >len</span>(s1), <span class=hljs-built_in >len</span>(s2)
    <span class=hljs-keyword >if</span> dp[i1][i2] == -<span class=hljs-number >1</span>:
        <span class=hljs-comment ># if we have reached the end of s1, then we have to insert all the remaining  characters of s2</span>
        <span class=hljs-keyword >if</span> i1 == n1:
            dp[i1][i2] = n2 - i2

        <span class=hljs-comment ># if we have reached the end of s2, then we have to delete all the remaining characters of s1</span>
        <span class=hljs-keyword >elif</span> i2 == n2:
            dp[i1][i2] = n1 - i1

        <span class=hljs-comment ># If the strings have a matching character, we can recursively match for the remaining lengths</span>
        <span class=hljs-keyword >elif</span> s1[i1] == s2[i2]:
            dp[i1][i2] = find_min_operations_recursive(
                dp, s1, s2, i1 + <span class=hljs-number >1</span>, i2 + <span class=hljs-number >1</span>)
        <span class=hljs-keyword >else</span>:
            c1 = find_min_operations_recursive(
                dp, s1, s2, i1 + <span class=hljs-number >1</span>, i2)  <span class=hljs-comment ># delete</span>
            c2 = find_min_operations_recursive(
                dp, s1, s2, i1, i2 + <span class=hljs-number >1</span>)  <span class=hljs-comment ># insert</span>
            c3 = find_min_operations_recursive(
                dp, s1, s2, i1 + <span class=hljs-number >1</span>, i2 + <span class=hljs-number >1</span>)  <span class=hljs-comment ># replace</span>
            dp[i1][i2] = <span class=hljs-number >1</span> + <span class=hljs-built_in >min</span>(c1, <span class=hljs-built_in >min</span>(c2, c3))

    <span class=hljs-keyword >return</span> dp[i1][i2]


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(find_min_operations(<span class=hljs-string >&quot;bat&quot;</span>, <span class=hljs-string >&quot;but&quot;</span>))
    <span class=hljs-built_in >print</span>(find_min_operations(<span class=hljs-string >&quot;abdca&quot;</span>, <span class=hljs-string >&quot;cbda&quot;</span>))
    <span class=hljs-built_in >print</span>(find_min_operations(<span class=hljs-string >&quot;passpot&quot;</span>, <span class=hljs-string >&quot;ppsspqrt&quot;</span>))


main()</code></pre> <p><strong>What is the time and space complexity of the above solution?</strong> <div class="admonition complexity"> <div class=admonition-title >üëâ Complexity</div> <div class=admonition-content >Since our memoization array <code>dp&#91;s1.length&#40;&#41;&#93;&#91;s2.length&#40;&#41;&#93;</code> stores the results for all the subproblems, we can conclude that we will not have more than <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>‚àó</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m * n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >‚àó</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> subproblems &#40;where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> are the lengths of the two input strings.&#41;. This means that our time complexity will be <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>m</mi><mo>‚àó</mo><mi>n</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(m * n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault">m</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >‚àó</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class=mclose >)</span></span></span></span>.</p> <p>The above algorithm will be using <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>m</mi><mo>‚àó</mo><mi>n</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(m * n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault">m</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >‚àó</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class=mclose >)</span></span></span></span> space for the memoization array. Other than that we will use <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault">m</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class=mclose >)</span></span></span></span> space for the recursion call-stack. So the total space complexity will be <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>m</mi><mo>‚àó</mo><mi>n</mi><mo>+</mo><mo stretchy=false >(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy=false >)</mo><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(m * n + (m+n))</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault">m</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >‚àó</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathdefault">m</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class=mclose >)</span><span class=mclose >)</span></span></span></span>, which is asymptotically equivalent to <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>m</mi><mo>‚àó</mo><mi>n</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault">m</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >‚àó</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class=mclose >)</span></span></span></span>.</div> </div> </p> <h2 id=bottom-up_dynamic_programming ><a href="#bottom-up_dynamic_programming" class=header-anchor >Bottom-up Dynamic Programming</a></h2> <p>Since we want to match all the characters of the given two strings, we can use a two-dimensional array to store our results. The lengths of the two strings will define the size of the two dimensions of the array. So for every index ‚Äòi1‚Äô in string ‚Äòs1‚Äô and ‚Äòi2‚Äô in string ‚Äòs2‚Äô, we will choose one of the following options:</p> <ul> <li><p>If the character <code>s1&#91;i1&#93;</code> matches <code>s2&#91;i2&#93;</code>, the count of the edit operations will be equal to the count of the edit operations for the remaining strings.</p> <li><p>If the character <code>s1&#91;i1&#93;</code> does not match <code>s2&#91;i2&#93;</code>, we will take the minimum count from the remaining strings after performing any of the three edit operations.</p> </ul> <p>So our recursive formula would be:</p> <pre><code class="python hljs"><span class=hljs-keyword >if</span> s1[i1] == s2[i2] 
    dp[i1][i2] = dp[i1-<span class=hljs-number >1</span>][i2-<span class=hljs-number >1</span>]
<span class=hljs-keyword >else</span> 
    dp[i1][i2] = <span class=hljs-number >1</span> + <span class=hljs-built_in >min</span>(dp[i1-<span class=hljs-number >1</span>][i2],  // delete
                        dp[i1][i2-<span class=hljs-number >1</span>],   // insert 
                        dp[i1-<span class=hljs-number >1</span>][i2-<span class=hljs-number >1</span>]) // replace</code></pre> <h3 id=code__3 ><a href="#code__3" class=header-anchor >Code</a></h3> <p>Here is the code for our bottom-up dynamic programming approach:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">find_min_operations</span>(<span class=hljs-params >s1, s2</span>):
  n1, n2 = <span class=hljs-built_in >len</span>(s1), <span class=hljs-built_in >len</span>(s2)
  dp = [[-<span class=hljs-number >1</span> <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n2+<span class=hljs-number >1</span>)] <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n1+<span class=hljs-number >1</span>)]

  <span class=hljs-comment ># if s2 is empty, we can remove all the characters of s1 to make it empty too</span>
  <span class=hljs-keyword >for</span> i1 <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n1+<span class=hljs-number >1</span>):
    dp[i1][<span class=hljs-number >0</span>] = i1

  <span class=hljs-comment ># if s1 is empty, we have to insert all the characters of s2</span>
  <span class=hljs-keyword >for</span> i2 <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n2+<span class=hljs-number >1</span>):
    dp[<span class=hljs-number >0</span>][i2] = i2

  <span class=hljs-keyword >for</span> i1 <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >1</span>, n1+<span class=hljs-number >1</span>):
    <span class=hljs-keyword >for</span> i2 <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >1</span>, n2+<span class=hljs-number >1</span>):
      <span class=hljs-comment ># If the strings have a matching character, we can recursively match for the remaining lengths</span>
      <span class=hljs-keyword >if</span> s1[i1 - <span class=hljs-number >1</span>] == s2[i2 - <span class=hljs-number >1</span>]:
        dp[i1][i2] = dp[i1 - <span class=hljs-number >1</span>][i2 - <span class=hljs-number >1</span>]
      <span class=hljs-keyword >else</span>:
        dp[i1][i2] = <span class=hljs-number >1</span> + <span class=hljs-built_in >min</span>(dp[i1 - <span class=hljs-number >1</span>][i2],  <span class=hljs-comment ># delete</span>
                             <span class=hljs-built_in >min</span>(dp[i1][i2 - <span class=hljs-number >1</span>],  <span class=hljs-comment ># insert</span>
                                 dp[i1 - <span class=hljs-number >1</span>][i2 - <span class=hljs-number >1</span>]))  <span class=hljs-comment ># replace</span>

  <span class=hljs-keyword >return</span> dp[n1][n2]


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
  <span class=hljs-built_in >print</span>(find_min_operations(<span class=hljs-string >&quot;bat&quot;</span>, <span class=hljs-string >&quot;but&quot;</span>))
  <span class=hljs-built_in >print</span>(find_min_operations(<span class=hljs-string >&quot;abdca&quot;</span>, <span class=hljs-string >&quot;cbda&quot;</span>))
  <span class=hljs-built_in >print</span>(find_min_operations(<span class=hljs-string >&quot;passpot&quot;</span>, <span class=hljs-string >&quot;ppsspqrt&quot;</span>))


main()</code></pre> <div class="admonition complexity"> <div class=admonition-title >üëâ Complexity</div> <div class=admonition-content >The time and space complexity of the above algorithm is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>n</mi><mo>‚àó</mo><mi>m</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(n*m)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault">n</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >‚àó</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> are the lengths of the two input strings.</div> </div> <h2 id=next ><a href="#next" class=header-anchor >Next</a></h2> <div class=flist ><ul> <li><p><a href="/Dynamic-Programming-Patterns/longest-common-substring/strings-interleaving" id=goto ><span id=check >&check;</span><span id=arrow ><b>&rarr;</b></span></a> Strings Interleaving</p> </ul></div> <div class=page-foot > <div class=copyright > &copy; Qling Alter. Last modified: June 20, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div> </div> <!-- end of class page-wrap-->