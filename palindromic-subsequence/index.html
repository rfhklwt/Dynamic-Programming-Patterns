<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/libs/katex/katex.min.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/libs/highlight/github.min.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/franklin.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/poole_hyde.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <title>Longest Palindromic Subsequence</title> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunr.min.js"></script> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunr_index.js"></script> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunrclient.min.js"></script> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <br> <img src="/Dynamic-Programming-Patterns/assets/infra/DP.svg" style="width: 160px; height: auto; display: inline"> <h1> <div style="line-height:18px; font-size: 20px; opacity: 0.85"><a href="/Dynamic-Programming-Patterns/">Dynamic Programming Patterns</a></div> </h1> <div style="line-height:18px; font-size: 15px; opacity: 0.85">by <a href="https://github.com/rfhklwt">Inia Owlet</a></div> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9"> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/"><b>Overview</b></a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/introduction"><b>Introduction</b></a> <br> <div class=course-section >Pattern 1: 0/1 Knapsack</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/"><b>1.0</b> - 0/1 Knapsack</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/equal-subset-sum-partition/"><b>1.1</b> - Equal Subset Sum Partition</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/subset-sum/"><b>1.2</b> - Subset Sum</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/minimum-subset-sum-difference/"><b>1.3</b> - Minimum Subset Sum Difference</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/count-of-subset-sum/"><b>1.4</b> - Count of Subset Sum</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/target-sum/"><b>1.5</b> - Target Sum</a> <div class=course-section >Pattern 2: Unbounded Knapsack</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/"><b>2.0</b> - Unbouned Knapsack</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/rod-cutting/"><b>2.1</b> - Rod Cutting</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/coin-change/"><b>2.2</b> - Coin Change</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/minimum-coin-change/"><b>2.3</b> - Minimum Coin Change</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/maximum-ribbon-cut/"><b>2.4</b> - Maximum Ribbon Cut</a> <div class=course-section >Pattern 3: Fibonacci Numbers</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/"><b>3.0</b> - Fibonacci Numbers</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/staircase/"><b>3.1</b> - Staircase</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/number-factors/"><b>3.2</b> - Number factors</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/minimum-jumps-to-reach-the-end/"><b>3.3</b> - Minimum jumps to reach the end</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/minimum-jumps-with-fee/"><b>3.4</b> - Minimum jumps with fee</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/house-thief/"><b>3.5</b> - House thief</a> <div class=course-section >Pattern 4: Palindromic Subsequence</div> <a class="sidebar-nav-item active" href="/Dynamic-Programming-Patterns/palindromic-subsequence/"><b>4.0</b> - Longest Palindromic Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/longest-palindromic-substring/"><b>4.1</b> - Longest Palindromic Substring</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/count-of-palindromic-substrings/"><b>4.2</b> - Count of Palindromic Substrings</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/minimum-deletions-in-a-string-to-make-it-a-palindrome/"><b>4.3</b> - Minimum Deletions in a String to make it a Palindrome</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/palindromic-partitioning/"><b>4.4</b> - Palindromic Partitioning</a> <div class=course-section >Pattern 5: Longest Common Substring</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/"><b>5.0</b> - Longest Common Substring</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-common-subsequence/"><b>5.1</b> - Longest Common Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/count-of-palindromic-substrings/"><b>5.2</b> - Minimum Deletions & Insertions to Transform a String into another</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/minimum-deletions&insertions-to-transform-a-string-into-another/"><b>4.0</b> - Longest Increasing Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/maximum-sum-increasing-subsequence/"><b>5.3</b> - Maximum Sum Increasing Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/shortest-common-super-sequence/"><b>5.4</b> - Shortest Common Super-sequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/count-of-palindromic-substrings/"><b>5.5</b> - Minimum Deletions to Make a Sequence Sorted</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-repeating-subsequence/"><b>5.6</b> - Longest Repeating Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/subsequence-pattern-matching/"><b>5.7</b> - Subsequence Pattern Matching</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-bitonic-subsequence/"><b>5.8</b> - Longest Bitonic Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-alternating-subsequence/"><b>5.9</b> - Longest Alternating Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/edit-distance/"><b>4.0</b> - Edit Distance</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/strings-interleaving/"><b>5.10</b> - Strings Interleaving</a> <br> </nav> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=longest_palindromic_subsequence ><a href="#longest_palindromic_subsequence" class=header-anchor >Longest Palindromic Subsequence</a></h1> <span style="font-size:24px;font-weight:300;">We'll cover the following</span> <div class=blank ></div> <div class=franklin-toc ><ol><li><a href="#problem_statement">Problem Statement</a><li><a href="#basic_solution">Basic Solution</a><ol><li><a href="#code">Code</a></ol><li><a href="#top-down_dynamic_programming_with_memoization">Top-down Dynamic Programming with Memoization</a><ol><li><a href="#code__2">Code</a></ol><li><a href="#bottom-up_dynamic_programming">Bottom-up Dynamic Programming</a><li><a href="#next">Next</a></ol></div> <div class=blank ></div> <h2 id=problem_statement ><a href="#problem_statement" class=header-anchor >Problem Statement</a></h2> <div class="admonition question"> <div class=admonition-title >üôã Question</div> <div class=admonition-content >Given a sequence, find the length of its Longest Palindromic Subsequence &#40;LPS&#41;. In a palindromic subsequence, elements read the same backward and forward.</div> </div> <div class=admonition ><div class=admonition-title >Info</div> <div class=content >A <a href="https://en.wikipedia.org/wiki/Subsequence">subsequence</a> is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</div></div> <ul> <li><p>Example 1</p> </ul> <pre><code class="Plaintext hljs">Input: &quot;abdbca&quot;
Output: 5
Explanation: LPS is &quot;abdba&quot;.</code></pre> <ul> <li><p>Example 2</p> </ul> <pre><code class="Plaintext hljs">Input: = &quot;cddpd&quot;
Output: 3
Explanation: LPS is &quot;ddd&quot;.</code></pre> <ul> <li><p>Example 3</p> </ul> <pre><code class="Plaintext hljs">Input: = &quot;pqr&quot;
Output: 1
Explanation: LPS could be &quot;p&quot;, &quot;q&quot; or &quot;r&quot;.</code></pre> <h2 id=basic_solution ><a href="#basic_solution" class=header-anchor >Basic Solution</a></h2> <p>A basic brute-force solution could be to try all the subsequences of the given sequence. We can start processing from the beginning and the end of the sequence. So at any step, we have two options:</p> <ul> <li><p>If the element at the beginning and the end are the same, we increment our count by two and make a recursive call for the remaining sequence.</p> <li><p>We will skip the element either from the beginning or the end to make two recursive calls for the remaining subsequence.</p> </ul> <p>If option one applies then it will give us the length of LPS; otherwise, the length of LPS will be the maximum number returned by the two recurse calls from the second option.</p> <h3 id=code ><a href="#code" class=header-anchor >Code</a></h3> <p>Here is the code:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">find_LPS_length</span>(<span class=hljs-params >st</span>):
    <span class=hljs-keyword >return</span> find_LPS_length_recursive(st, <span class=hljs-number >0</span>, <span class=hljs-built_in >len</span>(st) - <span class=hljs-number >1</span>)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">find_LPS_length_recursive</span>(<span class=hljs-params >st, startIndex, endIndex</span>):
    <span class=hljs-keyword >if</span> startIndex &gt; endIndex:
        <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>

    <span class=hljs-comment ># every sequence with one element is a palindrome of length 1</span>
    <span class=hljs-keyword >if</span> startIndex == endIndex:
        <span class=hljs-keyword >return</span> <span class=hljs-number >1</span>

    <span class=hljs-comment ># case 1: elements at the beginning and the end are the same</span>
    <span class=hljs-keyword >if</span> st[startIndex] == st[endIndex]:
        <span class=hljs-keyword >return</span> <span class=hljs-number >2</span> + find_LPS_length_recursive(st, startIndex + <span class=hljs-number >1</span>, endIndex - <span class=hljs-number >1</span>)

    <span class=hljs-comment ># case 2: skip one element either from the beginning or the end</span>
    c1 = find_LPS_length_recursive(st, startIndex + <span class=hljs-number >1</span>, endIndex)
    c2 = find_LPS_length_recursive(st, startIndex, endIndex - <span class=hljs-number >1</span>)
    <span class=hljs-keyword >return</span> <span class=hljs-built_in >max</span>(c1, c2)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(find_LPS_length(<span class=hljs-string >&quot;abdbca&quot;</span>))
    <span class=hljs-built_in >print</span>(find_LPS_length(<span class=hljs-string >&quot;cddpd&quot;</span>))
    <span class=hljs-built_in >print</span>(find_LPS_length(<span class=hljs-string >&quot;pqr&quot;</span>))


main()</code></pre> <div class="admonition complexity"> <div class=admonition-title >üëâ Complexity</div> <div class=admonition-content >In each function call, we are either having one recursive call or two recursive calls &#40;we will never have three recursive calls&#41;; hence, the time complexity of the above algorithm is exponential <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> is the length of the input sequence. The space complexity is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>n</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault">n</span><span class=mclose >)</span></span></span></span>, which is used to store the recursion stack.</div> </div> <h2 id=top-down_dynamic_programming_with_memoization ><a href="#top-down_dynamic_programming_with_memoization" class=header-anchor >Top-down Dynamic Programming with Memoization</a></h2> <p>We can use an array to store the already solved subproblems.</p> <p>The two changing values to our recursive function are the two indexes, startIndex and endIndex. Therefore, we can store the results of all the subproblems in a two-dimensional array. &#40;Another alternative could be to use a hash-table whose key would be a string &#40;startIndex &#43; ‚Äú|‚Äù &#43; endIndex&#41;&#41;</p> <h3 id=code__2 ><a href="#code__2" class=header-anchor >Code</a></h3> <p>Here is the code for this:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">find_LPS_length</span>(<span class=hljs-params >st</span>):
    n = <span class=hljs-built_in >len</span>(st)
    dp = [[-<span class=hljs-number >1</span> <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n)] <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n)]
    <span class=hljs-keyword >return</span> find_LPS_length_recursive(dp, st, <span class=hljs-number >0</span>, n - <span class=hljs-number >1</span>)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">find_LPS_length_recursive</span>(<span class=hljs-params >dp, st, startIndex, endIndex</span>):
    <span class=hljs-keyword >if</span> startIndex &gt; endIndex:
        <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>

    <span class=hljs-comment ># every sequence with one element is a palindrome of length 1</span>
    <span class=hljs-keyword >if</span> startIndex == endIndex:
        <span class=hljs-keyword >return</span> <span class=hljs-number >1</span>

    <span class=hljs-keyword >if</span> (dp[startIndex][endIndex] == -<span class=hljs-number >1</span>):
        <span class=hljs-comment ># case 1: elements at the beginning and the end are the same</span>
        <span class=hljs-keyword >if</span> st[startIndex] == st[endIndex]:
            dp[startIndex][endIndex] = <span class=hljs-number >2</span> + \
                find_LPS_length_recursive(dp, st, startIndex + <span class=hljs-number >1</span>, endIndex - <span class=hljs-number >1</span>)
        <span class=hljs-keyword >else</span>:
            <span class=hljs-comment ># case 2: skip one element either from the beginning or the end</span>
            c1 = find_LPS_length_recursive(dp, st, startIndex + <span class=hljs-number >1</span>, endIndex)
            c2 = find_LPS_length_recursive(dp, st, startIndex, endIndex - <span class=hljs-number >1</span>)
            dp[startIndex][endIndex] = <span class=hljs-built_in >max</span>(c1, c2)

    <span class=hljs-keyword >return</span> dp[startIndex][endIndex]


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(find_LPS_length(<span class=hljs-string >&quot;abdbca&quot;</span>))
    <span class=hljs-built_in >print</span>(find_LPS_length(<span class=hljs-string >&quot;cddpd&quot;</span>))
    <span class=hljs-built_in >print</span>(find_LPS_length(<span class=hljs-string >&quot;pqr&quot;</span>))


main()</code></pre> <p><strong>What is the time and space complexity of the above solution?</strong></p> <div class="admonition complexity"> <div class=admonition-title >üëâ Complexity</div> <div class=admonition-content >Since our memoization array <code>dp&#91;st.length&#40;&#41;&#93;&#91;st.length&#40;&#41;&#93;</code> stores the results for all the subproblems, we can conclude that we will not have more than N*NN‚àóN subproblems &#40;where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> is the length of the input sequence&#41;. This means that our time complexity will be <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>.</p> <p>The above algorithm will be using <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> space for the memoization array. Other than that we will use <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>N</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class=mclose >)</span></span></span></span> space for the recursion call-stack. So the total space complexity will be <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>+</mo><mi>N</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(N^2 + N)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class=mclose >)</span></span></span></span>, which is asymptotically equivalent to <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>.</div> </div> <h2 id=bottom-up_dynamic_programming ><a href="#bottom-up_dynamic_programming" class=header-anchor >Bottom-up Dynamic Programming</a></h2> <p>Since we want to try all the subsequences of the given sequence, we can use a two-dimensional array to store our results. We can start from the beginning of the sequence and keep adding one element at a time. At every step, we will try all of its subsequences. So for every <code>startIndex</code> and <code>endIndex</code> in the given string, we will choose one of the following two options:</p> <ul> <li><p>If the element at the <code>startIndex</code> matches the element at the <code>endIndex</code>, the length of LPS would be two plus the length of LPS till <code>startIndex&#43;1</code> and <code>endIndex-1</code>.</p> <li><p>If the element at the <code>startIndex</code> does not match the element at the <code>endIndex</code>, we will take the maximum LPS created by either skipping element at the <code>startIndex</code> or the <code>endIndex</code>.</p> </ul> <p>So our recursive formula would be:</p> <pre><code class="python hljs"><span class=hljs-keyword >if</span> st[endIndex] == st[startIndex] 
    dp[startIndex][endIndex] = <span class=hljs-number >2</span> + dp[startIndex + <span class=hljs-number >1</span>][endIndex - <span class=hljs-number >1</span>]
<span class=hljs-keyword >else</span> 
    dp[startIndex][endIndex] = Math.<span class=hljs-built_in >max</span>(dp[startIndex + <span class=hljs-number >1</span>][endIndex], dp[startIndex][endIndex - <span class=hljs-number >1</span>])</code></pre> <p>Let‚Äô s draw this visually for ‚Äúcddpd‚Äù, starting with a subsequence of length <code>1</code>. As we know, every sequence with one element is a palindrome of length 1:</p> <p><img src="/Dynamic-Programming-Patterns/assets/img/palindromic-subsequence/4.1.png" alt="" /></p> <p>From the above visualization, we can clearly see that the length of LPS is <code>3</code> as shown by <code>dp&#91;0&#93;&#91;4&#93;</code>.</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">find_LPS_length</span>(<span class=hljs-params >st</span>):
    n = <span class=hljs-built_in >len</span>(st)
    <span class=hljs-comment ># dp[i][j] stores the length of LPS from index &#x27;i&#x27; to index &#x27;j&#x27;</span>
    dp = [[<span class=hljs-number >0</span> <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n)] <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n)]

    <span class=hljs-comment ># every sequence with one element is a palindrome of length 1</span>
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n):
        dp[i][i] = <span class=hljs-number >1</span>

    <span class=hljs-keyword >for</span> startIndex <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n - <span class=hljs-number >1</span>, -<span class=hljs-number >1</span>, -<span class=hljs-number >1</span>):
        <span class=hljs-keyword >for</span> endIndex <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(startIndex + <span class=hljs-number >1</span>, n):
            <span class=hljs-comment ># case 1: elements at the beginning and the end are the same</span>
            <span class=hljs-keyword >if</span> st[startIndex] == st[endIndex]:
                dp[startIndex][endIndex] = <span class=hljs-number >2</span> + dp[startIndex + <span class=hljs-number >1</span>][endIndex - <span class=hljs-number >1</span>]
            <span class=hljs-keyword >else</span>:  <span class=hljs-comment ># case 2: skip one element either from the beginning or the end</span>
                dp[startIndex][endIndex] = <span class=hljs-built_in >max</span>(
                    dp[startIndex + <span class=hljs-number >1</span>][endIndex], dp[startIndex][endIndex - <span class=hljs-number >1</span>])

    <span class=hljs-keyword >return</span> dp[<span class=hljs-number >0</span>][n - <span class=hljs-number >1</span>]


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(find_LPS_length(<span class=hljs-string >&quot;abdbca&quot;</span>))
    <span class=hljs-built_in >print</span>(find_LPS_length(<span class=hljs-string >&quot;cddpd&quot;</span>))
    <span class=hljs-built_in >print</span>(find_LPS_length(<span class=hljs-string >&quot;pqr&quot;</span>))


main()</code></pre> <div class="admonition complexity"> <div class=admonition-title >üëâ Complexity</div> <div class=admonition-content >The time and space complexity of the above algorithm is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathdefault">n</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> is the length of the input sequence.</div> </div> <h2 id=next ><a href="#next" class=header-anchor >Next</a></h2> <div class=flist ><ul> <li><p><a href="/Dynamic-Programming-Patterns/palindromic-subsequence/longest-palindromic-substring" id=goto ><span id=check >&check;</span><span id=arrow ><b>&rarr;</b></span></a> Longest Palindromic Substring</p> </ul></div> <div class=page-foot > <div class=copyright > &copy; Qling Alter. Last modified: June 20, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div> </div> <!-- end of class page-wrap-->