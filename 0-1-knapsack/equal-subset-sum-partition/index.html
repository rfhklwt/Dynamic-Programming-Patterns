<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/libs/katex/katex.min.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/libs/highlight/github.min.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/franklin.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/poole_hyde.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <title>Count of Subset Sum</title> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunr.min.js"></script> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunr_index.js"></script> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunrclient.min.js"></script> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <br> <img src="/Dynamic-Programming-Patterns/assets/infra/DP.svg" style="width: 160px; height: auto; display: inline"> <h1> <div style="line-height:18px; font-size: 20px; opacity: 0.85"><a href="/Dynamic-Programming-Patterns/">Dynamic Programming Patterns</a></div> </h1> <div style="line-height:18px; font-size: 15px; opacity: 0.85">by <a href="https://github.com/rfhklwt">Inia Owlet</a></div> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9"> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/"><b>Overview</b></a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/introduction"><b>Introduction</b></a> <br> <div class=course-section >Pattern 1: 0/1 Knapsack</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/"><b>1.0</b> - 0/1 Knapsack</a> <a class="sidebar-nav-item active" href="/Dynamic-Programming-Patterns/0-1-knapsack/equal-subset-sum-partition/"><b>1.1</b> - Equal Subset Sum Partition</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/subset-sum/"><b>1.2</b> - Subset Sum</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/minimum-subset-sum-difference/"><b>1.3</b> - Minimum Subset Sum Difference</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/count-of-subset-sum/"><b>1.4</b> - Count of Subset Sum</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/target-sum/"><b>1.5</b> - Target Sum</a> <div class=course-section >Pattern 2: Unbounded Knapsack</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/"><b>2.0</b> - Unbouned Knapsack</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/rod-cutting/"><b>2.1</b> - Rod Cutting</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/coin-change/"><b>2.2</b> - Coin Change</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/minimum-coin-change/"><b>2.3</b> - Minimum Coin Change</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/maximum-ribbon-cut/"><b>2.4</b> - Maximum Ribbon Cut</a> <div class=course-section >Pattern 3: Fibonacci Numbers</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/"><b>3.0</b> - Fibonacci Numbers</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/staircase/"><b>3.1</b> - Staircase</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/number-factors/"><b>3.2</b> - Number factors</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/minimum-jumps-to-reach-the-end/"><b>3.3</b> - Minimum jumps to reach the end</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/minimum-jumps-with-fee/"><b>3.4</b> - Minimum jumps with fee</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/house-thief/"><b>3.5</b> - House thief</a> <div class=course-section >Pattern 4: Palindromic Subsequence</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/"><b>4.0</b> - Longest Palindromic Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/longest-palindromic-substring/"><b>4.1</b> - Longest Palindromic Substring</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/count-of-palindromic-substrings/"><b>4.2</b> - Count of Palindromic Substrings</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/minimum-deletions-in-a-string-to-make-it-a-palindrome/"><b>4.3</b> - Minimum Deletions in a String to make it a Palindrome</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/palindromic-partitioning/"><b>4.4</b> - Palindromic Partitioning</a> <div class=course-section >Pattern 5: Longest Common Substring</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/"><b>5.0</b> - Longest Common Substring</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-common-subsequence/"><b>5.1</b> - Longest Common Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/count-of-palindromic-substrings/"><b>5.2</b> - Minimum Deletions & Insertions to Transform a String into another</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/minimum-deletions&insertions-to-transform-a-string-into-another/"><b>4.0</b> - Longest Increasing Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/maximum-sum-increasing-subsequence/"><b>5.3</b> - Maximum Sum Increasing Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/shortest-common-super-sequence/"><b>5.4</b> - Shortest Common Super-sequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/count-of-palindromic-substrings/"><b>5.5</b> - Minimum Deletions to Make a Sequence Sorted</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-repeating-subsequence/"><b>5.6</b> - Longest Repeating Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/subsequence-pattern-matching/"><b>5.7</b> - Subsequence Pattern Matching</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-bitonic-subsequence/"><b>5.8</b> - Longest Bitonic Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-alternating-subsequence/"><b>5.9</b> - Longest Alternating Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/edit-distance/"><b>4.0</b> - Edit Distance</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/strings-interleaving/"><b>5.10</b> - Strings Interleaving</a> <br> </nav> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=count_of_subset_sum ><a href="#count_of_subset_sum" class=header-anchor >Count of Subset Sum</a></h1> <span style="font-size:24px;font-weight:300;">We'll cover the following</span> <div class=blank ></div> <div class=franklin-toc ><ol><li><a href="#problem_statement">Problem Statement</a><li><a href="#basic_solution">Basic Solution</a><ol><li><a href="#code">Code</a></ol><li><a href="#top-down_dynamic_programming_with_memoization">Top-down Dynamic Programming with Memoization</a><ol><li><a href="#code__2">Code</a></ol><li><a href="#bottom-up_dynamic_programming">Bottom-up Dynamic Programming</a><ol><li><a href="#code__3">Code</a></ol><li><a href="#next">Next</a></ol></div> <div class=blank ></div> <h2 id=problem_statement ><a href="#problem_statement" class=header-anchor >Problem Statement</a></h2> <div class="admonition question"> <div class=admonition-title >ðŸ™‹ Question</div> <div class=admonition-content >Given a set of positive numbers, find if we can partition it into two subsets such that the sum of elements in both the subsets is equal.</div> </div> <ul> <li><p>Example 1</p> </ul> <pre><code class="Plaintext hljs">Input: {1, 2, 3, 4}
Output: True
Explanation: The given set can be partitioned into two subsets with equal sum: {1, 4} &amp; {2, 3}</code></pre> <ul> <li><p>Example 2</p> </ul> <pre><code class="Plaintext hljs">Input: {1, 1, 3, 4, 7}
Output: True
Explanation: The given set can be partitioned into two subsets with equal sum: {1, 3, 4} &amp; {1, 7}</code></pre> <ul> <li><p>Example 3</p> </ul> <pre><code class="Plaintext hljs">Input: {2, 3, 4, 6}
Output: False
Explanation: The given set cannot be partitioned into two subsets with equal sum.</code></pre> <h2 id=basic_solution ><a href="#basic_solution" class=header-anchor >Basic Solution</a></h2> <p>This problem follows the <strong>0/1 Knapsack pattern</strong>. A basic brute-force solution could be to try all combinations of partitioning the given numbers into two sets to see if any pair of sets has an equal sum.</p> <p>Assume if <code>S</code> represents the total sum of all the given numbers, then the two equal subsets must have a sum equal to <code>S/2</code>. This essentially transforms our problem to: &quot;Find a subset of the given numbers that has a total sum of <code>S/2</code>&quot;.</p> <p>So our brute-force algorithm will look like:</p> <pre><code class="Plaintext hljs">for each number &#x27;i&#x27; 
    create a new set which INCLUDES number &#x27;i&#x27; if it does not exceed &#x27;S/2&#x27;, and recursively 
        process the remaining numbers
    create a new set WITHOUT number &#x27;i&#x27;, and recursively process the remaining items 
return true if any of the above sets has a sum equal to &#x27;S/2&#x27;, otherwise return false</code></pre> <h3 id=code ><a href="#code" class=header-anchor >Code</a></h3> <p>Here is the code for the brute-force solution:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">can_partition</span>(<span class=hljs-params >num</span>):
    s = <span class=hljs-built_in >sum</span>(num)
    <span class=hljs-comment ># if &#x27;s&#x27; is a an odd number, we can&#x27;t have two subsets with equal sum</span>
    <span class=hljs-keyword >if</span> s % <span class=hljs-number >2</span> != <span class=hljs-number >0</span>:
        <span class=hljs-keyword >return</span> <span class=hljs-literal >False</span>

    <span class=hljs-keyword >return</span> can_partition_recursive(num, s / <span class=hljs-number >2</span>, <span class=hljs-number >0</span>)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">can_partition_recursive</span>(<span class=hljs-params >num, <span class=hljs-built_in >sum</span>, currentIndex</span>):
    <span class=hljs-comment ># base check</span>
    <span class=hljs-keyword >if</span> <span class=hljs-built_in >sum</span> == <span class=hljs-number >0</span>:
        <span class=hljs-keyword >return</span> <span class=hljs-literal >True</span>

    n = <span class=hljs-built_in >len</span>(num)
    <span class=hljs-keyword >if</span> n == <span class=hljs-number >0</span> <span class=hljs-keyword >or</span> currentIndex &gt;= n:
        <span class=hljs-keyword >return</span> <span class=hljs-literal >False</span>

    <span class=hljs-comment ># recursive call after choosing the number at the `currentIndex`</span>
    <span class=hljs-comment ># if the number at `currentIndex` exceeds the sum, we shouldn&#x27;t process this</span>
    <span class=hljs-keyword >if</span> num[currentIndex] &lt;= <span class=hljs-built_in >sum</span>:
        <span class=hljs-keyword >if</span>(can_partition_recursive(num, <span class=hljs-built_in >sum</span> - num[currentIndex], currentIndex + <span class=hljs-number >1</span>)):
            <span class=hljs-keyword >return</span> <span class=hljs-literal >True</span>

    <span class=hljs-comment ># recursive call after excluding the number at the &#x27;currentIndex&#x27;</span>
    <span class=hljs-keyword >return</span> can_partition_recursive(num, <span class=hljs-built_in >sum</span>, currentIndex + <span class=hljs-number >1</span>)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>, <span class=hljs-number >4</span>])))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >1</span>, <span class=hljs-number >1</span>, <span class=hljs-number >3</span>, <span class=hljs-number >4</span>, <span class=hljs-number >7</span>])))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >2</span>, <span class=hljs-number >3</span>, <span class=hljs-number >4</span>, <span class=hljs-number >6</span>])))


main()</code></pre> <div class="admonition complexity"> <div class=admonition-title >ðŸ‘‰ Complexity</div> <div class=admonition-content >The time complexity of the above algorithm is exponential <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> represents the total number. The space complexity is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>n</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault">n</span><span class=mclose >)</span></span></span></span>, this memory which will be used to store the recursion stack.</div> </div> <h2 id=top-down_dynamic_programming_with_memoization ><a href="#top-down_dynamic_programming_with_memoization" class=header-anchor >Top-down Dynamic Programming with Memoization</a></h2> <p>We can use memoization to overcome the overlapping sub-problems. As stated in previous lessons, memoization is when we store the results of all the previously solved sub-problems return the results from memory if we encounter a problem that has already been solved.</p> <p>Since we need to store the results for every subset and for every possible sum, therefore we will be using a two-dimensional array to store the results of the solved sub-problems. The first dimension of the array will represent different subsets and the second dimension will represent different â€˜sumsâ€™ that we can calculate from each subset. These two dimensions of the array can also be inferred from the two changing values &#40;sum and currentIndex&#41; in our recursive function <code>canPartitionRecursive&#40;&#41;</code>.</p> <h3 id=code__2 ><a href="#code__2" class=header-anchor >Code</a></h3> <p>Here is the code for Top-down DP with memoization:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">can_partition</span>(<span class=hljs-params >num</span>):
    s = <span class=hljs-built_in >sum</span>(num)

    <span class=hljs-comment ># if &#x27;s&#x27; is a an odd number, we can&#x27;t have two subsets with equal sum</span>
    <span class=hljs-keyword >if</span> s % <span class=hljs-number >2</span> != <span class=hljs-number >0</span>:
        <span class=hljs-keyword >return</span> <span class=hljs-literal >False</span>

    <span class=hljs-comment ># initialize the &#x27;dp&#x27; array, -1 for default, 1 for true and 0 for false</span>
    dp = [[-<span class=hljs-number >1</span> <span class=hljs-keyword >for</span> x <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-built_in >int</span>(s/<span class=hljs-number >2</span>)+<span class=hljs-number >1</span>)] <span class=hljs-keyword >for</span> y <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-built_in >len</span>(num))]
    <span class=hljs-keyword >return</span> <span class=hljs-literal >True</span> <span class=hljs-keyword >if</span> can_partition_recursive(dp, num, <span class=hljs-built_in >int</span>(s / <span class=hljs-number >2</span>), <span class=hljs-number >0</span>) == <span class=hljs-number >1</span> <span class=hljs-keyword >else</span> <span class=hljs-literal >False</span>


<span class=hljs-keyword >def</span> <span class="hljs-title function_">can_partition_recursive</span>(<span class=hljs-params >dp, num, <span class=hljs-built_in >sum</span>, currentIndex</span>):
    <span class=hljs-comment ># base check</span>
    <span class=hljs-keyword >if</span> <span class=hljs-built_in >sum</span> == <span class=hljs-number >0</span>:
        <span class=hljs-keyword >return</span> <span class=hljs-number >1</span>

    n = <span class=hljs-built_in >len</span>(num)
    <span class=hljs-keyword >if</span> n == <span class=hljs-number >0</span> <span class=hljs-keyword >or</span> currentIndex &gt;= n:
        <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>

    <span class=hljs-comment ># if we have not already processed a similar problem</span>
    <span class=hljs-keyword >if</span> dp[currentIndex][<span class=hljs-built_in >sum</span>] == -<span class=hljs-number >1</span>:
        <span class=hljs-comment ># recursive call after choosing the number at the currentIndex</span>
        <span class=hljs-comment ># if the number at currentIndex exceeds the sum, we shouldn&#x27;t process this</span>
        <span class=hljs-keyword >if</span> num[currentIndex] &lt;= <span class=hljs-built_in >sum</span>:
            <span class=hljs-keyword >if</span> can_partition_recursive(dp, num, <span class=hljs-built_in >sum</span> - num[currentIndex], currentIndex + <span class=hljs-number >1</span>) == <span class=hljs-number >1</span>:
                dp[currentIndex][<span class=hljs-built_in >sum</span>] = <span class=hljs-number >1</span>
                <span class=hljs-keyword >return</span> <span class=hljs-number >1</span>

        <span class=hljs-comment ># recursive call after excluding the number at the currentIndex</span>
        dp[currentIndex][<span class=hljs-built_in >sum</span>] = can_partition_recursive(
            dp, num, <span class=hljs-built_in >sum</span>, currentIndex + <span class=hljs-number >1</span>)

    <span class=hljs-keyword >return</span> dp[currentIndex][<span class=hljs-built_in >sum</span>]


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>, <span class=hljs-number >4</span>])))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >1</span>, <span class=hljs-number >1</span>, <span class=hljs-number >3</span>, <span class=hljs-number >4</span>, <span class=hljs-number >7</span>])))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >2</span>, <span class=hljs-number >3</span>, <span class=hljs-number >4</span>, <span class=hljs-number >6</span>])))


main()</code></pre> <div class="admonition complexity"> <div class=admonition-title >ðŸ‘‰ Complexity</div> <div class=admonition-content >The above algorithm has time and space complexity of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>N</mi><mo>âˆ—</mo><mi>S</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(N*S)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >âˆ—</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> represents total numbers and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> is the total sum of all the numbers.</div> </div> <h2 id=bottom-up_dynamic_programming ><a href="#bottom-up_dynamic_programming" class=header-anchor >Bottom-up Dynamic Programming</a></h2> <p>Letâ€™s try to populate our <code>dp&#91;&#93;&#91;&#93;</code> array from the above solution, working in a bottom-up fashion. Essentially, we want to find if we can make all possible sums with every subset. This means, dp&#91;i&#93;&#91;s&#93; will be â€˜trueâ€™ if we can make sum <code>s</code> from the first <code>i</code> numbers.</p> <p>So, for each number at index <code>i</code> &#40;0 &lt;&#61; i &lt; num.length&#41; and sum <code>s</code> &#40;0 &lt;&#61; s &lt;&#61; S/2&#41;, we have two options:</p> <p>Exclude the number. In this case, we will see if we can get <code>s</code> from the subset excluding this number: <code>dp&#91;i-1&#93;&#91;s&#93;</code> Include the number if its value is not more than <code>s</code>. In this case, we will see if we can find a subset to get the remaining sum: <code>dp&#91;i-1&#93;&#91;s-num&#91;i&#93;&#93;</code> If either of the two above scenarios is true, we can find a subset of numbers with a sum equal to <code>s</code>.</p> <p>Letâ€™s start with our base case of zero capacity:</p> <p><img src="/Dynamic-Programming-Patterns/assets/img/0-1-knapsack/1.8.png" alt="" /></p> <p>From the above visualization, we can clearly see that it is possible to partition the given set into two subsets with equal sums, as shown by bottom-right cell: <code>dp&#91;3&#93;&#91;5&#93; &#61;&gt; T</code>.</p> <h3 id=code__3 ><a href="#code__3" class=header-anchor >Code</a></h3> <p>Here is the code for our bottom-up dynamic programming approach:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">can_partition</span>(<span class=hljs-params >num</span>):
    s = <span class=hljs-built_in >sum</span>(num)

    <span class=hljs-comment ># if &#x27;s&#x27; is a an odd number, we can&#x27;t have two subsets with same total</span>
    <span class=hljs-keyword >if</span> s % <span class=hljs-number >2</span> != <span class=hljs-number >0</span>:
        <span class=hljs-keyword >return</span> <span class=hljs-literal >False</span>

    <span class=hljs-comment ># we are trying to find a subset of given numbers that has a total sum of &#x27;s/2&#x27;.</span>
    s = <span class=hljs-built_in >int</span>(s / <span class=hljs-number >2</span>)

    n = <span class=hljs-built_in >len</span>(num)
    dp = [[<span class=hljs-literal >False</span> <span class=hljs-keyword >for</span> x <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(s+<span class=hljs-number >1</span>)] <span class=hljs-keyword >for</span> y <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n)]

    <span class=hljs-comment ># populate the sum=0 column, as we can always have &#x27;0&#x27; sum without including</span>
    <span class=hljs-comment ># any element</span>
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >0</span>, n):
        dp[i][<span class=hljs-number >0</span>] = <span class=hljs-literal >True</span>

    <span class=hljs-comment ># with only one number, we can form a subset only when the required sum is</span>
    <span class=hljs-comment ># equal to its value</span>
    <span class=hljs-keyword >for</span> j <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >1</span>, s+<span class=hljs-number >1</span>):
        dp[<span class=hljs-number >0</span>][j] = num[<span class=hljs-number >0</span>] == j

    <span class=hljs-comment ># process all subsets for all sums</span>
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >1</span>, n):
        <span class=hljs-keyword >for</span> j <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >1</span>, s+<span class=hljs-number >1</span>):
            <span class=hljs-comment ># if we can get the sum &#x27;j&#x27; without the number at index &#x27;i&#x27;</span>
            <span class=hljs-keyword >if</span> dp[i - <span class=hljs-number >1</span>][j]:
                dp[i][j] = dp[i - <span class=hljs-number >1</span>][j]
            <span class=hljs-keyword >elif</span> j &gt;= num[i]:  <span class=hljs-comment ># else if we can find a subset to get the remaining sum</span>
                dp[i][j] = dp[i - <span class=hljs-number >1</span>][j - num[i]]

    <span class=hljs-comment ># the bottom-right corner will have our answer.</span>
    <span class=hljs-keyword >return</span> dp[n - <span class=hljs-number >1</span>][s]


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>, <span class=hljs-number >4</span>])))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >1</span>, <span class=hljs-number >1</span>, <span class=hljs-number >3</span>, <span class=hljs-number >4</span>, <span class=hljs-number >7</span>])))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >2</span>, <span class=hljs-number >3</span>, <span class=hljs-number >4</span>, <span class=hljs-number >6</span>])))


main()</code></pre> <div class="admonition complexity"> <div class=admonition-title >ðŸ‘‰ Complexity</div> <div class=admonition-content >The above solution has time and space complexity of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>N</mi><mo>âˆ—</mo><mi>S</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(N*S)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >âˆ—</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> represents total numbers and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> is the total sum of all the numbers.</div> </div> <h2 id=next ><a href="#next" class=header-anchor >Next</a></h2> <div class=flist ><ul> <li><p><a href="/Dynamic-Programming-Patterns/0-1-knapsack/subset-sum" id=goto ><span id=check >&check;</span><span id=arrow ><b>&rarr;</b></span></a> Subset Sum</p> </ul></div> <div class=page-foot > <div class=copyright > &copy; Qling Alter. Last modified: June 20, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div> </div> <!-- end of class page-wrap-->