<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/libs/katex/katex.min.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/libs/highlight/github.min.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/franklin.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/poole_hyde.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <title>Minimum Subset Sum Difference</title> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunr.min.js"></script> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunr_index.js"></script> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunrclient.min.js"></script> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <br> <img src="/Dynamic-Programming-Patterns/assets/infra/DP.svg" style="width: 160px; height: auto; display: inline"> <h1> <div style="line-height:18px; font-size: 20px; opacity: 0.85"><a href="/Dynamic-Programming-Patterns/">Dynamic Programming Patterns</a></div> </h1> <div style="line-height:18px; font-size: 15px; opacity: 0.85">by <a href="https://github.com/rfhklwt">Inia Owlet</a></div> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9"> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/"><b>Overview</b></a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/introduction"><b>Introduction</b></a> <br> <div class=course-section >Pattern 1: 0/1 Knapsack</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/"><b>1.0</b> - 0/1 Knapsack</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/equal-subset-sum-partition/"><b>1.1</b> - Equal Subset Sum Partition</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/subset-sum/"><b>1.2</b> - Subset Sum</a> <a class="sidebar-nav-item active" href="/Dynamic-Programming-Patterns/0-1-knapsack/minimum-subset-sum-difference/"><b>1.3</b> - Minimum Subset Sum Difference</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/count-of-subset-sum/"><b>1.4</b> - Count of Subset Sum</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/target-sum/"><b>1.5</b> - Target Sum</a> <div class=course-section >Pattern 2: Unbounded Knapsack</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/"><b>2.0</b> - Unbouned Knapsack</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/rod-cutting/"><b>2.1</b> - Rod Cutting</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/coin-change/"><b>2.2</b> - Coin Change</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/minimum-coin-change/"><b>2.3</b> - Minimum Coin Change</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/maximum-ribbon-cut/"><b>2.4</b> - Maximum Ribbon Cut</a> <div class=course-section >Pattern 3: Fibonacci Numbers</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/"><b>3.0</b> - Fibonacci Numbers</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/staircase/"><b>3.1</b> - Staircase</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/number-factors/"><b>3.2</b> - Number factors</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/minimum-jumps-to-reach-the-end/"><b>3.3</b> - Minimum jumps to reach the end</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/minimum-jumps-with-fee/"><b>3.4</b> - Minimum jumps with fee</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/house-thief/"><b>3.5</b> - House thief</a> <div class=course-section >Pattern 4: Palindromic Subsequence</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/"><b>4.0</b> - Longest Palindromic Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/longest-palindromic-substring/"><b>4.1</b> - Longest Palindromic Substring</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/count-of-palindromic-substrings/"><b>4.2</b> - Count of Palindromic Substrings</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/minimum-deletions-in-a-string-to-make-it-a-palindrome/"><b>4.3</b> - Minimum Deletions in a String to make it a Palindrome</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/palindromic-partitioning/"><b>4.4</b> - Palindromic Partitioning</a> <div class=course-section >Pattern 5: Longest Common Substring</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/"><b>5.0</b> - Longest Common Substring</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-common-subsequence/"><b>5.1</b> - Longest Common Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/count-of-palindromic-substrings/"><b>5.2</b> - Minimum Deletions & Insertions to Transform a String into another</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/minimum-deletions&insertions-to-transform-a-string-into-another/"><b>4.0</b> - Longest Increasing Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/maximum-sum-increasing-subsequence/"><b>5.3</b> - Maximum Sum Increasing Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/shortest-common-super-sequence/"><b>5.4</b> - Shortest Common Super-sequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/count-of-palindromic-substrings/"><b>5.5</b> - Minimum Deletions to Make a Sequence Sorted</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-repeating-subsequence/"><b>5.6</b> - Longest Repeating Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/subsequence-pattern-matching/"><b>5.7</b> - Subsequence Pattern Matching</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-bitonic-subsequence/"><b>5.8</b> - Longest Bitonic Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-alternating-subsequence/"><b>5.9</b> - Longest Alternating Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/edit-distance/"><b>4.0</b> - Edit Distance</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/strings-interleaving/"><b>5.10</b> - Strings Interleaving</a> <br> </nav> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=minimum_subset_sum_difference ><a href="#minimum_subset_sum_difference" class=header-anchor >Minimum Subset Sum Difference</a></h1> <span style="font-size:24px;font-weight:300;">We'll cover the following</span> <div class=blank ></div> <div class=franklin-toc ><ol><li><a href="#problem_statement">Problem Statement</a><li><a href="#basic_solution">Basic Solution</a><ol><li><a href="#code">Code</a></ol><li><a href="#top-down_dynamic_programming_with_memoization">Top-down Dynamic Programming with Memoization</a><ol><li><a href="#code__2">Code</a></ol><li><a href="#bottom-up_dynamic_programming">Bottom-up Dynamic Programming</a><ol><li><a href="#code__3">Code</a></ol><li><a href="#next">Next</a></ol></div> <div class=blank ></div> <h2 id=problem_statement ><a href="#problem_statement" class=header-anchor >Problem Statement</a></h2> <div class="admonition question"> <div class=admonition-title >ðŸ™‹ Question</div> <div class=admonition-content >Given a set of positive numbers, partition the set into two subsets with a minimum difference between their subset sums.</div> </div> <ul> <li><p>Example 1</p> </ul> <pre><code class="Plaintext hljs">Input: {1, 2, 3, 9}
Output: 3
Explanation: We can partition the given set into two subsets where the minimum absolute difference 
between the sum of numbers is &#x27;3&#x27;. Following are the two subsets: {1, 2, 3} &amp; {9}.</code></pre> <ul> <li><p>Example 2</p> </ul> <pre><code class="Plaintext hljs">Input: {1, 2, 7, 1, 5}
Output: 0
Explanation: We can partition the given set into two subsets where the minimum absolute difference 
between the sum of numbers is &#x27;0&#x27;. Following are the two subsets: {1, 2, 5} &amp; {7, 1}.</code></pre> <ul> <li><p>Example 3</p> </ul> <pre><code class="Plaintext hljs">Input: {1, 3, 100, 4}
Output: 92
Explanation: We can partition the given set into two subsets where the minimum absolute difference 
between the sum of numbers is &#x27;92&#x27;. Here are the two subsets: {1, 3, 4} &amp; {100}.</code></pre> <h2 id=basic_solution ><a href="#basic_solution" class=header-anchor >Basic Solution</a></h2> <p>This problem follows the <strong>0/1 Knapsack pattern</strong> and can be converted into a <a href="/Dynamic-Programming-Patterns/0-1-knapsack/subset-sum">Subset Sum</a> problem.</p> <p>Letâ€™s assume S1 and S2 are the two desired subsets. A basic brute-force solution could be to try adding each element either in S1 or S2, to find the combination that gives the minimum sum difference between the two sets.</p> <p>So our brute-force algorithm will look like:</p> <pre><code class="Plaintext hljs">for each number &#x27;i&#x27; 
    add number &#x27;i&#x27; to S1 and recursively process the remaining numbers
    add number &#x27;i&#x27; to S2 and recursively process the remaining numbers
return the minimum absolute difference of the above two sets</code></pre> <h3 id=code ><a href="#code" class=header-anchor >Code</a></h3> <p>Here is the code for the brute-force solution:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">can_partition</span>(<span class=hljs-params >num</span>):
    <span class=hljs-keyword >return</span> can_partition_recursive(num, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">can_partition_recursive</span>(<span class=hljs-params >num, currentIndex, sum1, sum2</span>):
    <span class=hljs-comment ># base check</span>
    <span class=hljs-keyword >if</span> currentIndex == <span class=hljs-built_in >len</span>(num):
        <span class=hljs-keyword >return</span> <span class=hljs-built_in >abs</span>(sum1 - sum2)

    <span class=hljs-comment ># recursive call after including the number at the currentIndex in the first set</span>
    diff1 = can_partition_recursive(
        num, currentIndex + <span class=hljs-number >1</span>, sum1 + num[currentIndex], sum2)

    <span class=hljs-comment ># recursive call after including the number at the currentIndex in the second set</span>
    diff2 = can_partition_recursive(
        num, currentIndex + <span class=hljs-number >1</span>, sum1, sum2 + num[currentIndex])

    <span class=hljs-keyword >return</span> <span class=hljs-built_in >min</span>(diff1, diff2)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>, <span class=hljs-number >9</span>])))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >7</span>, <span class=hljs-number >1</span>, <span class=hljs-number >5</span>])))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >1</span>, <span class=hljs-number >3</span>, <span class=hljs-number >100</span>, <span class=hljs-number >4</span>])))


main()</code></pre> <div class="admonition complexity"> <div class=admonition-title >ðŸ‘‰ Complexity</div> <div class=admonition-content >The time complexity of the above algorithm is exponential <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> represents the total number. The space complexity is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>n</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault">n</span><span class=mclose >)</span></span></span></span> which is used to store the recursion stack.</div> </div> <h2 id=top-down_dynamic_programming_with_memoization ><a href="#top-down_dynamic_programming_with_memoization" class=header-anchor >Top-down Dynamic Programming with Memoization</a></h2> <p>We can use memoization to overcome the overlapping sub-problems.</p> <p>We will be using a two-dimensional array to store the results of the solved sub-problems. We can uniquely identify a sub-problem from <code>currentIndex</code> and <code>Sum1</code>; as <code>Sum2</code> will always be the sum of the remaining numbers.</p> <h3 id=code__2 ><a href="#code__2" class=header-anchor >Code</a></h3> <p>Here is the code:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">can_partition</span>(<span class=hljs-params >num</span>):
    s = <span class=hljs-built_in >sum</span>(num)
    dp = [[-<span class=hljs-number >1</span> <span class=hljs-keyword >for</span> x <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(s+<span class=hljs-number >1</span>)] <span class=hljs-keyword >for</span> y <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-built_in >len</span>(num))]
    <span class=hljs-keyword >return</span> can_partition_recursive(dp, num, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>, <span class=hljs-number >0</span>)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">can_partition_recursive</span>(<span class=hljs-params >dp, num, currentIndex, sum1, sum2</span>):
    <span class=hljs-comment ># base check</span>
    <span class=hljs-keyword >if</span> currentIndex == <span class=hljs-built_in >len</span>(num):
        <span class=hljs-keyword >return</span> <span class=hljs-built_in >abs</span>(sum1 - sum2)

    <span class=hljs-comment ># check if we have not already processed similar problem</span>
    <span class=hljs-keyword >if</span> dp[currentIndex][sum1] == -<span class=hljs-number >1</span>:
        <span class=hljs-comment ># recursive call after including the number at the currentIndex in the first set</span>
        diff1 = can_partition_recursive(
            dp, num, currentIndex + <span class=hljs-number >1</span>, sum1 + num[currentIndex], sum2)

        <span class=hljs-comment ># recursive call after including the number at the currentIndex in the second set</span>
        diff2 = can_partition_recursive(
            dp, num, currentIndex + <span class=hljs-number >1</span>, sum1, sum2 + num[currentIndex])

        dp[currentIndex][sum1] = <span class=hljs-built_in >min</span>(diff1, diff2)

    <span class=hljs-keyword >return</span> dp[currentIndex][sum1]


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>, <span class=hljs-number >9</span>])))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >7</span>, <span class=hljs-number >1</span>, <span class=hljs-number >5</span>])))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >1</span>, <span class=hljs-number >3</span>, <span class=hljs-number >100</span>, <span class=hljs-number >4</span>])))


main()</code></pre> <h2 id=bottom-up_dynamic_programming ><a href="#bottom-up_dynamic_programming" class=header-anchor >Bottom-up Dynamic Programming</a></h2> <p>Letâ€™s assume <code>S</code> represents the total sum of all the numbers. So what we are trying to achieve in this problem is to find a subset whose sum is as close to <code>S/2</code> as possible, because if we can partition the given set into two subsets of an equal sum, we get the minimum difference i.e. zero. This transforms our problem to Subset Sum, where we try to find a subset whose sum is equal to a given numberâ€“ <code>S/2</code> in our case. If we canâ€™t find such a subset, then we will take the subset which has the sum closest to <code>S/2</code>. This is easily possible, as we will be calculating all possible sums with every subset.</p> <p>Essentially, we need to calculate all the possible sums up to <code>S/2</code> for all numbers. So how do we populate the array <code>dp&#91;TotalNumbers&#93;&#91;S/2&#43;1&#93;</code> in the bottom-up fashion?</p> <p>For every possible sum <code>s</code> &#40;where 0 &lt;&#61; s &lt;&#61; S/2&#41;, we have two options:</p> <ul> <li><p>Exclude the number. In this case, we will see if we can get the sum <code>s</code> from the subset excluding this number &#61;&gt; <code>dp&#91;index-1&#93;&#91;s&#93;</code></p> <li><p>Include the number if its value is not more than <code>s</code>. In this case, we will see if we can find a subset to get the remaining sum &#61;&gt; <code>dp&#91;index-1&#93;&#91;s-num&#91;index&#93;&#93;</code></p> </ul> <p>If either of the two above scenarios is true, we can find a subset with a sum equal to <code>s</code>. We should dig into this before we can learn how to find the closest subset.</p> <p>Letâ€™s draw this visually, with the example input &#123;1, 2, 3, 9&#125;. Since the total sum is <code>15</code>, therefore, we will try to find a subset whose sum is equal to the half of it i.e. <code>7</code>.</p> <p><img src="/Dynamic-Programming-Patterns/assets/img/0-1-knapsack/1.6.png" alt="" /></p> <div class="admonition note"> <div class=admonition-title >âš  Note</div> <div class=admonition-content >The above visualization tells us that it is not possible to find a subset whose sum is equal to <code>7</code>. So what is the closest subset we can find? We can find such a subset if we start moving backward in the last row from the bottom right corner to find the first <code>T</code>. The first <code>T</code> in the above diagram is the sum <code>6</code>, which means we can find a subset whose sum is equal to <code>6</code>. This means the other set will have a sum of <code>9</code>, and the minimum difference will be <code>3</code>.</div> </div> <h3 id=code__3 ><a href="#code__3" class=header-anchor >Code</a></h3> <p>Here is the code for our bottom-up dynamic programming approach:</p> <pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">can_partition</span>(<span class=hljs-params >num</span>):
    s = <span class=hljs-built_in >sum</span>(num)
    n = <span class=hljs-built_in >len</span>(num)
    dp = [[<span class=hljs-literal >False</span> <span class=hljs-keyword >for</span> x <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-built_in >int</span>(s/<span class=hljs-number >2</span>)+<span class=hljs-number >1</span>)] <span class=hljs-keyword >for</span> y <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n)]

    <span class=hljs-comment ># populate the s=0 columns, as we can always form &#x27;0&#x27; sum with an empty set</span>
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >0</span>, n):
        dp[i][<span class=hljs-number >0</span>] = <span class=hljs-literal >True</span>

    <span class=hljs-comment ># with only one number, we can form a subset only when the required sum is equal to that number</span>
    <span class=hljs-keyword >for</span> j <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >1</span>, <span class=hljs-built_in >int</span>(s/<span class=hljs-number >2</span>)+<span class=hljs-number >1</span>):
        dp[<span class=hljs-number >0</span>][j] = num[<span class=hljs-number >0</span>] == j

    <span class=hljs-comment ># process all subsets for all sums</span>
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >1</span>, n):
        <span class=hljs-keyword >for</span> j <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >1</span>, <span class=hljs-built_in >int</span>(s/<span class=hljs-number >2</span>)+<span class=hljs-number >1</span>):
            <span class=hljs-comment ># if we can get the sum &#x27;s&#x27; without the number at index &#x27;i&#x27;</span>
            <span class=hljs-keyword >if</span> dp[i - <span class=hljs-number >1</span>][j]:
                dp[i][j] = dp[i - <span class=hljs-number >1</span>][j]
            <span class=hljs-keyword >elif</span> j &gt;= num[i]:
                <span class=hljs-comment ># else include the number and see if we can find a subset to get the remaining sum</span>
                dp[i][j] = dp[i - <span class=hljs-number >1</span>][j - num[i]]

    sum1 = <span class=hljs-number >0</span>
    <span class=hljs-comment ># find the largest index in the last row which is true</span>
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-built_in >int</span>(s/<span class=hljs-number >2</span>), -<span class=hljs-number >1</span>, -<span class=hljs-number >1</span>):
        <span class=hljs-keyword >if</span> dp[n - <span class=hljs-number >1</span>][i]:
            sum1 = i
            <span class=hljs-keyword >break</span>

    sum2 = s - sum1
    <span class=hljs-keyword >return</span> <span class=hljs-built_in >abs</span>(sum2 - sum1)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>, <span class=hljs-number >9</span>])))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >7</span>, <span class=hljs-number >1</span>, <span class=hljs-number >5</span>])))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Can partition: &quot;</span> + <span class=hljs-built_in >str</span>(can_partition([<span class=hljs-number >1</span>, <span class=hljs-number >3</span>, <span class=hljs-number >100</span>, <span class=hljs-number >4</span>])))


main()</code></pre> <div class="admonition complexity"> <div class=admonition-title >ðŸ‘‰ Complexity</div> <div class=admonition-content >The above solution has time and space complexity of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>N</mi><mo>âˆ—</mo><mi>S</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(N*S)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >âˆ—</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class=mclose >)</span></span></span></span>, where <code>N</code> represents total numbers and <code>S</code> is the total sum of all the numbers.</div> </div> <h2 id=next ><a href="#next" class=header-anchor >Next</a></h2> <div class=flist ><ul> <li><p><a href="/Dynamic-Programming-Patterns/0-1-knapsack/count-of-subset-sum" id=goto ><span id=check >&check;</span><span id=arrow ><b>&rarr;</b></span></a> Count of Subset Sum</p> </ul></div> <div class=page-foot > <div class=copyright > &copy; Qling Alter. Last modified: June 20, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div> </div> <!-- end of class page-wrap-->