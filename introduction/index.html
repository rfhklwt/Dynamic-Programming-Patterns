<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/libs/highlight/github.min.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/franklin.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/poole_hyde.css"> <link rel=stylesheet  href="/Dynamic-Programming-Patterns/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <title>What is Dynamic Programming?</title> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunr.min.js"></script> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunr_index.js"></script> <script src="/Dynamic-Programming-Patterns/libs/lunr/lunrclient.min.js"></script> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <br> <img src="/Dynamic-Programming-Patterns/assets/infra/DP.svg" style="width: 160px; height: auto; display: inline"> <h1> <div style="line-height:18px; font-size: 20px; opacity: 0.85"><a href="/Dynamic-Programming-Patterns/">Dynamic Programming Patterns</a></div> </h1> <div style="line-height:18px; font-size: 15px; opacity: 0.85">by <a href="https://github.com/rfhklwt">Inia Owlet</a></div> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9"> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/"><b>Overview</b></a> <a class="sidebar-nav-item active" href="/Dynamic-Programming-Patterns/introduction"><b>Introduction</b></a> <br> <div class=course-section >Pattern 1: 0/1 Knapsack</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/"><b>1.0</b> - 0/1 Knapsack</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/equal-subset-sum-partition/"><b>1.1</b> - Equal Subset Sum Partition</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/subset-sum/"><b>1.2</b> - Subset Sum</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/minimum-subset-sum-difference/"><b>1.3</b> - Minimum Subset Sum Difference</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/count-of-subset-sum/"><b>1.4</b> - Count of Subset Sum</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/0-1-knapsack/target-sum/"><b>1.5</b> - Target Sum</a> <div class=course-section >Pattern 2: Unbounded Knapsack</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/"><b>2.0</b> - Unbouned Knapsack</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/rod-cutting/"><b>2.1</b> - Rod Cutting</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/coin-change/"><b>2.2</b> - Coin Change</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/minimum-coin-change/"><b>2.3</b> - Minimum Coin Change</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/unbounded-knapsack/maximum-ribbon-cut/"><b>2.4</b> - Maximum Ribbon Cut</a> <div class=course-section >Pattern 3: Fibonacci Numbers</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/"><b>3.0</b> - Fibonacci Numbers</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/staircase/"><b>3.1</b> - Staircase</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/number-factors/"><b>3.2</b> - Number factors</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/minimum-jumps-to-reach-the-end/"><b>3.3</b> - Minimum jumps to reach the end</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/minimum-jumps-with-fee/"><b>3.4</b> - Minimum jumps with fee</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/fibonacci-numbers/house-thief/"><b>3.5</b> - House thief</a> <div class=course-section >Pattern 4: Palindromic Subsequence</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/"><b>4.0</b> - Longest Palindromic Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/longest-palindromic-substring/"><b>4.1</b> - Longest Palindromic Substring</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/count-of-palindromic-substrings/"><b>4.2</b> - Count of Palindromic Substrings</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/minimum-deletions-in-a-string-to-make-it-a-palindrome/"><b>4.3</b> - Minimum Deletions in a String to make it a Palindrome</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/palindromic-subsequence/palindromic-partitioning/"><b>4.4</b> - Palindromic Partitioning</a> <div class=course-section >Pattern 5: Longest Common Substring</div> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/"><b>5.0</b> - Longest Common Substring</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-common-subsequence/"><b>5.1</b> - Longest Common Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/minimum-deletions&insertions-to-transform-a-string-into-another/"><b>5.2</b> - Minimum Deletions & Insertions to Transform a String into another</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-increasing-subsequence/"><b>5.3</b> - Longest Increasing Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/maximum-sum-increasing-subsequence/"><b>5.4</b> - Maximum Sum Increasing Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/shortest-common-super-sequence/"><b>5.5</b> - Shortest Common Super-sequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/minimum-deletions-to-make-a-sequence-sorted/"><b>5.6</b> - Minimum Deletions to Make a Sequence Sorted</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-repeating-subsequence/"><b>5.7</b> - Longest Repeating Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/subsequence-pattern-matching/"><b>5.8</b> - Subsequence Pattern Matching</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-bitonic-subsequence/"><b>5.9</b> - Longest Bitonic Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/longest-alternating-subsequence/"><b>5.10</b> - Longest Alternating Subsequence</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/edit-distance/"><b>5.11</b> - Edit Distance</a> <a class="sidebar-nav-item " href="/Dynamic-Programming-Patterns/longest-common-substring/strings-interleaving/"><b>5.12</b> - Strings Interleaving</a> <br> </nav> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=what_is_dynamic_programming ><a href="#what_is_dynamic_programming" class=header-anchor >What is Dynamic Programming?</a></h1> <span style="font-size:24px;font-weight:300;">We'll cover the following</span> <div class=blank ></div> <div class=franklin-toc ><ol><li><a href="#characteristics_of_dynamic_programming">Characteristics of Dynamic Programming</a><ol><li><a href="#overlapping_subproblems">Overlapping Subproblems</a><li><a href="#optimal_substructure_property">Optimal Substructure Property</a></ol><li><a href="#dynamic_programming_methods">Dynamic Programming Methods</a><ol><li><a href="#top-down_with_memoization">Top-down with Memoization</a><li><a href="#bottom-up_with_tabulation">Bottom-up with Tabulation</a></ol><li><a href="#next">Next</a></ol></div> <div class=blank ></div> <p>Dynamic Programming &#40;DP&#41; is an algorithmic technique for solving an optimization problem by breaking it down into simpler subproblems and utilizing the fact that the optimal solution to the overall problem depends upon the optimal solution to its subproblems.</p> <p>Let’s take the example of the <strong>Fibonacci numbers</strong>. As we all know, Fibonacci numbers are a series of numbers in which each number is the sum of the two preceding numbers. The first few Fibonacci numbers are 0, 1, 1, 2, 3, 5, and 8, and they continue on from there.</p> <p>If we are asked to calculate the nth Fibonacci number, we can do that with the following equation,</p> <pre><code class="Plaintext hljs">Fib(n) = Fib(n-1) + Fib(n-2), for n &gt; 1</code></pre>
<p>As we can clearly see here, to solve the overall problem &#40;i.e. <code>Fib&#40;n&#41;</code>&#41;, we broke it down into two smaller subproblems &#40;which are <code>Fib&#40;n-1&#41;</code> and <code>Fib&#40;n-2&#41;</code>&#41;. This shows that we can use DP to solve this problem.</p>
<h2 id=characteristics_of_dynamic_programming ><a href="#characteristics_of_dynamic_programming" class=header-anchor >Characteristics of Dynamic Programming</a></h2>
<p>Before moving on to understand different methods of solving a DP problem, let’s first take a look at what are the characteristics of a problem that tells us that we can apply DP to solve it.</p>
<h3 id=overlapping_subproblems ><a href="#overlapping_subproblems" class=header-anchor >Overlapping Subproblems</a></h3>
<p>Subproblems are smaller versions of the original problem. Any problem has overlapping sub-problems if finding its solution involves solving the same subproblem multiple times. Take the example of the Fibonacci numbers; to find the <code>fib&#40;4&#41;</code>, we need to break it down into the following sub-problems:</p>
<p><img src="/Dynamic-Programming-Patterns/assets/img/0.png" alt="" /></p>
<p>We can clearly see the overlapping subproblem pattern here, as <code>fib&#40;2&#41;</code> has been evaluated twice and <code>fib&#40;1&#41;</code> has been evaluated three times.</p>
<h3 id=optimal_substructure_property ><a href="#optimal_substructure_property" class=header-anchor >Optimal Substructure Property</a></h3>
<p>Any problem has optimal substructure property if its overall optimal solution can be constructed from the optimal solutions of its subproblems. For Fibonacci numbers, as we know,</p>
<pre><code class="Plaintext hljs">Fib(n) = Fib(n-1) + Fib(n-2)</code></pre>
<p>This clearly shows that a problem of size <code>n</code> has been reduced to subproblems of size <code>n-1</code> and <code>n-2</code>. Therefore, Fibonacci numbers have optimal substructure property.</p>
<h2 id=dynamic_programming_methods ><a href="#dynamic_programming_methods" class=header-anchor >Dynamic Programming Methods</a></h2>
<p>DP offers two methods to solve a problem.</p>
<h3 id=top-down_with_memoization ><a href="#top-down_with_memoization" class=header-anchor >Top-down with Memoization</a></h3>
<p>In this approach, we try to solve the bigger problem by recursively finding the solution to smaller sub-problems. Whenever we solve a sub-problem, we cache its result so that we don’t end up solving it repeatedly if it’s called multiple times. Instead, we can just return the saved result. This technique of storing the results of already solved subproblems is called <strong>Memoization</strong>.</p>
<p>We’ll see this technique in our example of Fibonacci numbers. First, let’s see the non-DP recursive solution for finding the nth Fibonacci number:</p>
<pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">calculateFibonacci</span>(<span class=hljs-params >n</span>):
    <span class=hljs-keyword >if</span> n &lt; <span class=hljs-number >2</span>:
        <span class=hljs-keyword >return</span> n

    <span class=hljs-keyword >return</span> calculateFibonacci(n - <span class=hljs-number >1</span>) + calculateFibonacci(n - <span class=hljs-number >2</span>)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;5th Fibonacci is ---&gt; &quot;</span> + <span class=hljs-built_in >str</span>(calculateFibonacci(<span class=hljs-number >5</span>)))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;6th Fibonacci is ---&gt; &quot;</span> + <span class=hljs-built_in >str</span>(calculateFibonacci(<span class=hljs-number >6</span>)))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;7th Fibonacci is ---&gt; &quot;</span> + <span class=hljs-built_in >str</span>(calculateFibonacci(<span class=hljs-number >7</span>)))

main()</code></pre>
<p>As we saw above, this problem shows the overlapping subproblems pattern, so let’s make use of memoization here. We can use an array to store the already solved subproblems &#40;see the changes in the highlighted lines&#41;.</p>
<pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">calculateFibonacci</span>(<span class=hljs-params >n</span>):
    memoize = [-<span class=hljs-number >1</span> <span class=hljs-keyword >for</span> x <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(n+<span class=hljs-number >1</span>)]
    <span class=hljs-keyword >return</span> calculateFibonacciRecur(memoize, n)


<span class=hljs-keyword >def</span> <span class="hljs-title function_">calculateFibonacciRecur</span>(<span class=hljs-params >memoize, n</span>):
    <span class=hljs-keyword >if</span> n &lt; <span class=hljs-number >2</span>:
        <span class=hljs-keyword >return</span> n

    <span class=hljs-comment ># if we have already solved this subproblem, simply return the result from the cache</span>
    <span class=hljs-keyword >if</span> memoize[n] &gt;= <span class=hljs-number >0</span>:
        <span class=hljs-keyword >return</span> memoize[n]

    memoize[n] = calculateFibonacciRecur(
        memoize, n - <span class=hljs-number >1</span>) + calculateFibonacciRecur(memoize, n - <span class=hljs-number >2</span>)
    <span class=hljs-keyword >return</span> memoize[n]


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;5th Fibonacci is ---&gt; &quot;</span> + <span class=hljs-built_in >str</span>(calculateFibonacci(<span class=hljs-number >5</span>)))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;6th Fibonacci is ---&gt; &quot;</span> + <span class=hljs-built_in >str</span>(calculateFibonacci(<span class=hljs-number >6</span>)))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;7th Fibonacci is ---&gt; &quot;</span> + <span class=hljs-built_in >str</span>(calculateFibonacci(<span class=hljs-number >7</span>)))


main()</code></pre>
<h3 id=bottom-up_with_tabulation ><a href="#bottom-up_with_tabulation" class=header-anchor >Bottom-up with Tabulation</a></h3>
<p>Tabulation is the opposite of the top-down approach and avoids recursion. In this approach, we solve the problem “bottom-up” &#40;i.e. by solving all the related sub-problems first&#41;. This is typically done by filling up an n-dimensional table. Based on the results in the table, the solution to the top/original problem is then computed.</p>
<p>Tabulation is the opposite of Memoization, as in Memoization we solve the problem and maintain a map of already solved sub-problems. In other words, in memoization, we do it top-down in the sense that we solve the top problem first &#40;which typically recurses down to solve the sub-problems&#41;.</p>
<p>Let’s apply Tabulation to our example of Fibonacci numbers. Since we know that every Fibonacci number is the sum of the two preceding numbers, we can use this fact to populate our table.</p>
<p>Here is the code for our bottom-up dynamic programming approach:</p>
<pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">calculateFibonacci</span>(<span class=hljs-params >n</span>):
    dp = [<span class=hljs-number >0</span>, <span class=hljs-number >1</span>]
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-built_in >range</span>(<span class=hljs-number >2</span>, n + <span class=hljs-number >1</span>):
        dp.append(dp[i - <span class=hljs-number >1</span>] + dp[i - <span class=hljs-number >2</span>])

    <span class=hljs-keyword >return</span> dp[n]


<span class=hljs-keyword >def</span> <span class="hljs-title function_">main</span>():
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;5th Fibonacci is ---&gt; &quot;</span> + <span class=hljs-built_in >str</span>(calculateFibonacci(<span class=hljs-number >5</span>)))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;6th Fibonacci is ---&gt; &quot;</span> + <span class=hljs-built_in >str</span>(calculateFibonacci(<span class=hljs-number >6</span>)))
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;7th Fibonacci is ---&gt; &quot;</span> + <span class=hljs-built_in >str</span>(calculateFibonacci(<span class=hljs-number >7</span>)))


main()</code></pre>
<p><strong>In this course, we will always start with a brute-force recursive solution, which is the best way to start solving any DP problem&#33;</strong> Once we have a recursive solution then we will apply Memoization and Tabulation techniques.</p>
<p>Let’s apply this knowledge to solve some of the frequently asked DP problems.</p>
<h2 id=next ><a href="#next" class=header-anchor >Next</a></h2>
<div class=flist ><ul>
<li><p><a href="/Dynamic-Programming-Patterns/0-1-knapsack/" id=goto ><span id=check >&check;</span><span id=arrow ><b>&rarr;</b></span></a> 0/1 Knapsack Patterns</p>

</ul></div>
<div class=page-foot >
  <div class=copyright >
    &copy; Qling Alter. Last modified: June 20, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div> 
    </div> 
    </div> <!-- end of class page-wrap-->